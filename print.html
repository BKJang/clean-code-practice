<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Do you know vanilla?</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="basic/01-PrimitivevsObject.html"><strong aria-hidden="true">1.</strong> Basic</a></li><li><ol class="section"><li><a href="basic/01-PrimitivevsObject.html"><strong aria-hidden="true">1.1.</strong> Primitive(값) vs Object(참조)</a></li><li><a href="basic/02-conversion.html"><strong aria-hidden="true">1.2.</strong> 명시적 변환 vs 암묵적 변환</a></li><li><a href="basic/03-Scope.html"><strong aria-hidden="true">1.3.</strong> Functional Scope vs Block Scope</a></li><li><a href="basic/04-this-binding.html"><strong aria-hidden="true">1.4.</strong> this binding</a></li><li><a href="basic/05-prototype.html"><strong aria-hidden="true">1.5.</strong> prototype</a></li><li><a href="basic/06-execution-context.html"><strong aria-hidden="true">1.6.</strong> 실행 컨텍스트(Execution Context)</a></li><li><a href="basic/07-Closure.html"><strong aria-hidden="true">1.7.</strong> 클로저(Closure)</a></li><li><a href="basic/08-Template-Literal.html"><strong aria-hidden="true">1.8.</strong> 템플릿 리터럴(Template Literal)</a></li><li><a href="basic/09-Arrow-Function.html"><strong aria-hidden="true">1.9.</strong> 화살표 함수(Arrow Function)</a></li><li><a href="basic/10-Spread.html"><strong aria-hidden="true">1.10.</strong> Spread연산자 &amp; rest파라미터</a></li><li><a href="basic/11-Destructuring.html"><strong aria-hidden="true">1.11.</strong> Destructuring(비구조화 할당)</a></li><li><a href="basic/12-Class.html"><strong aria-hidden="true">1.12.</strong> Class(클래스)</a></li><li><a href="basic/13-Module.html"><strong aria-hidden="true">1.13.</strong> Module(모듈)</a></li><li><a href="14-Promise&Async-Await.html"><strong aria-hidden="true">1.14.</strong> Promise와 async-await</a></li><li><a href="15-Iteration-Protocol.html"><strong aria-hidden="true">1.15.</strong> Iteration Protocol</a></li><li><a href="16-Generator.html"><strong aria-hidden="true">1.16.</strong> Generator</a></li></ol></li><li><a href="advance/01-EventLoop.html"><strong aria-hidden="true">2.</strong> Advance</a></li><li><ol class="section"><li><a href="advance/01-EventLoop.html"><strong aria-hidden="true">2.1.</strong> Event Loop</a></li><li><a href="advance/02-repaint&reflow.html"><strong aria-hidden="true">2.2.</strong> repaint와 reflow</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <style>
  header.warning {
    background-color: rgb(242, 222, 222);
    border-bottom-color: rgb(238, 211, 215);
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-bottom-style: solid;
    border-bottom-width: 0.666667px;
    border-image-outset: 0 0 0 0;
    border-image-repeat: stretch stretch;
    border-image-slice: 100% 100% 100% 100%;
    border-image-source: none;
    border-image-width: 1 1 1 1;
    border-left-color: rgb(238, 211, 215);
    border-left-style: solid;
    border-left-width: 0.666667px;
    border-right-color: rgb(238, 211, 215);
    border-right-style: solid;
    border-right-width: 0.666667px;
    border-top-color: rgb(238, 211, 215);
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border-top-style: solid;
    border-top-width: 0.666667px;
    color: rgb(185, 74, 72);
    margin-bottom: 0px;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 30px;
    padding-bottom: 8px;
    padding-left: 14px;
    padding-right: 35px;
    padding-top: 8px;
    text-align: center;
  }
</style>

                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Do you know vanilla?</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#primitive값-vs-object참조" id="primitive값-vs-object참조"><h2>Primitive(값) vs Object(참조)</h2></a>
<a class="header" href="#primitive-type" id="primitive-type"><h2>Primitive Type</h2></a>
<ul>
<li>String : 텍스트를 셋팅하는데 사용하는 타입.</li>
<li>Number : 숫자를 셋팅하는데 사용하는 타입. 기본적으로 소수점도 가능하다.(infinity, -inifinity, NaN 표현이 가능하다.)</li>
<li>Null : null타입은 정확히는 1개의 값은 가지고 있지만 비어있다는 뜻이다.</li>
<li>Undefined : 값이 할당되지 않는 것을 나타내는 타입.</li>
<li>Boolean : true 또는 false 로 나타내는 타입.</li>
<li>Symbol : 새로 추가된 타입으로 <strong>unique하고 immutable한 원시값</strong> 으로 사용된다.(ES6)</li>
</ul>
<a class="header" href="#primitive-type의-생성-방법" id="primitive-type의-생성-방법"><h3>Primitive Type의 생성 방법</h3></a>
<ol>
<li>Literal</li>
</ol>
<ul>
<li>Literal로 생성한다고 하면 우리가 가장 많이 사용하는 방법</li>
</ul>
<pre><code class="language-js">var bol = true;
var str = &quot;hello&quot;;
var num = 3.14;
var nullType = null;
var undef = undefined;

var bol2;
var str2;
bo2 = false
str2 = &quot;world&quot;
</code></pre>
<ol start="2">
<li>
<p>Wrapper Object</p>
</li>
</ol>
<ul>
<li>Wrapper Object를 사용해서 만든다고 하면 Constructor를 사용해서 만드는 것</li>
<li>즉, <code>new</code> 를 사용하여 생성</li>
</ul>
<pre><code class="language-js">new Boolean(false);
new String(&quot;world&quot;);
new Number(42);

Symbol(&quot;foo&quot;); //Symbol 타입의 생성방법
</code></pre>
<a class="header" href="#literal-vs-wrapper" id="literal-vs-wrapper"><h3>Literal vs Wrapper</h3></a>
<pre><code class="language-js">typeof true; //&quot;boolean&quot;
typeof Boolean(true); //&quot;boolean&quot;
typeof new Boolean(true); //&quot;object&quot;
typeof (new Boolean(true)).valueOf(); //&quot;boolean&quot;
     
typeof &quot;abc&quot;; //&quot;string&quot;
typeof String(&quot;abc&quot;); //&quot;string&quot;
typeof new String(&quot;abc&quot;); //&quot;object&quot;
typeof (new String(&quot;abc&quot;)).valueOf(); //&quot;string&quot;
     
typeof 123; //&quot;number&quot;
typeof Number(123); //&quot;number&quot;
typeof new Number(123); //&quot;object&quot;
typeof (new Number(123)).valueOf(); //&quot;number&quot;
</code></pre>
<p>Literal로 생성한 것의 타입은 6가지 중 하나로 나오게 된다. 그런데 new를 사용하여 Wrapper Object로 만들게 되면 Object타입이 나오게 된다. 사용을 하려면 valueOf라는 Function을 사용해야만 입력한 값이 나오게 된다.</p>
<a class="header" href="#값-타입" id="값-타입"><h3>값 타입</h3></a>
<pre><code class="language-js">var a = 13         // assign `13` to `a`
var b = a          // copy the value of `a` to `b`

b = 37             // assign `37` to `b`

console.log(a)     // =&gt; 13
</code></pre>
<p>b의 값을 변경을 했지만 a에는 영향이 가지 않았다. 이유는 2개의 값이 저장된 공간이 다르기 때문이다.</p>
<a class="header" href="#object-type" id="object-type"><h2>Object Type</h2></a>
<ul>
<li>Array : 우리가 알고 있는 배열, 리스트의 형태를 가지고 있다.</li>
<li>Function : Javascript에서는 Function Object가 존재하지만 결국 Function도 Object.</li>
<li>Object : Map처럼 사용하는 즉, key : value의 형태로 사용하고 있는 Object.</li>
</ul>
<pre><code class="language-js">var a = { c: 13 }  // assign the reference of a new object to `a`
var b = a          // copy the reference of the object inside `a` to new variable `b`
b.c = 37           // modify the contents of the object `b` refers to
console.log(a)     // =&gt; { c: 37 }
</code></pre>
<pre><code class="language-js">var a = [];
var b = a;

a.push(1);

console.log(a); // [1]
console.log(b); // [1]
console.log(a === b); // true
</code></pre>
<pre><code class="language-js">function changeAgeImpure(person) {
    person.age = 25;
    return person;
}
var alex = {
    name: 'Alex',
    age: 30
};
var changedAlex = changeAgeImpure(alex);

console.log(alex); // -&gt; { name: 'Alex', age: 25 }
console.log(changedAlex); // -&gt; { name: 'Alex', age: 25 }
</code></pre>
<p>원시타입과는 다르게 복사한 것을 변경을 했더니 기존 객체에도 영향이 간다. 이유는 <strong>같은 값의 주소</strong>를 복사했기 때문이다.</p>
<hr />
<a class="header" href="#-reference" id="-reference"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/B_Type.md">ImD/Dev-Docs - javascript Type</a></li>
</ul>
<a class="header" href="#primitive값-vs-object참조-1" id="primitive값-vs-object참조-1"><h2>Primitive(값) vs Object(참조)</h2></a>
<a class="header" href="#primitive-type-1" id="primitive-type-1"><h2>Primitive Type</h2></a>
<ul>
<li>String : 텍스트를 셋팅하는데 사용하는 타입.</li>
<li>Number : 숫자를 셋팅하는데 사용하는 타입. 기본적으로 소수점도 가능하다.(infinity, -inifinity, NaN 표현이 가능하다.)</li>
<li>Null : null타입은 정확히는 1개의 값은 가지고 있지만 비어있다는 뜻이다.</li>
<li>Undefined : 값이 할당되지 않는 것을 나타내는 타입.</li>
<li>Boolean : true 또는 false 로 나타내는 타입.</li>
<li>Symbol : 새로 추가된 타입으로 <strong>unique하고 immutable한 원시값</strong> 으로 사용된다.(ES6)</li>
</ul>
<a class="header" href="#primitive-type의-생성-방법-1" id="primitive-type의-생성-방법-1"><h3>Primitive Type의 생성 방법</h3></a>
<ol>
<li>Literal</li>
</ol>
<ul>
<li>Literal로 생성한다고 하면 우리가 가장 많이 사용하는 방법</li>
</ul>
<pre><code class="language-js">var bol = true;
var str = &quot;hello&quot;;
var num = 3.14;
var nullType = null;
var undef = undefined;

var bol2;
var str2;
bo2 = false
str2 = &quot;world&quot;
</code></pre>
<ol start="2">
<li>
<p>Wrapper Object</p>
</li>
</ol>
<ul>
<li>Wrapper Object를 사용해서 만든다고 하면 Constructor를 사용해서 만드는 것</li>
<li>즉, <code>new</code> 를 사용하여 생성</li>
</ul>
<pre><code class="language-js">new Boolean(false);
new String(&quot;world&quot;);
new Number(42);

Symbol(&quot;foo&quot;); //Symbol 타입의 생성방법
</code></pre>
<a class="header" href="#literal-vs-wrapper-1" id="literal-vs-wrapper-1"><h3>Literal vs Wrapper</h3></a>
<pre><code class="language-js">typeof true; //&quot;boolean&quot;
typeof Boolean(true); //&quot;boolean&quot;
typeof new Boolean(true); //&quot;object&quot;
typeof (new Boolean(true)).valueOf(); //&quot;boolean&quot;
     
typeof &quot;abc&quot;; //&quot;string&quot;
typeof String(&quot;abc&quot;); //&quot;string&quot;
typeof new String(&quot;abc&quot;); //&quot;object&quot;
typeof (new String(&quot;abc&quot;)).valueOf(); //&quot;string&quot;
     
typeof 123; //&quot;number&quot;
typeof Number(123); //&quot;number&quot;
typeof new Number(123); //&quot;object&quot;
typeof (new Number(123)).valueOf(); //&quot;number&quot;
</code></pre>
<p>Literal로 생성한 것의 타입은 6가지 중 하나로 나오게 된다. 그런데 new를 사용하여 Wrapper Object로 만들게 되면 Object타입이 나오게 된다. 사용을 하려면 valueOf라는 Function을 사용해야만 입력한 값이 나오게 된다.</p>
<a class="header" href="#값-타입-1" id="값-타입-1"><h3>값 타입</h3></a>
<pre><code class="language-js">var a = 13         // assign `13` to `a`
var b = a          // copy the value of `a` to `b`

b = 37             // assign `37` to `b`

console.log(a)     // =&gt; 13
</code></pre>
<p>b의 값을 변경을 했지만 a에는 영향이 가지 않았다. 이유는 2개의 값이 저장된 공간이 다르기 때문이다.</p>
<a class="header" href="#object-type-1" id="object-type-1"><h2>Object Type</h2></a>
<ul>
<li>Array : 우리가 알고 있는 배열, 리스트의 형태를 가지고 있다.</li>
<li>Function : Javascript에서는 Function Object가 존재하지만 결국 Function도 Object.</li>
<li>Object : Map처럼 사용하는 즉, key : value의 형태로 사용하고 있는 Object.</li>
</ul>
<pre><code class="language-js">var a = { c: 13 }  // assign the reference of a new object to `a`
var b = a          // copy the reference of the object inside `a` to new variable `b`
b.c = 37           // modify the contents of the object `b` refers to
console.log(a)     // =&gt; { c: 37 }
</code></pre>
<pre><code class="language-js">var a = [];
var b = a;

a.push(1);

console.log(a); // [1]
console.log(b); // [1]
console.log(a === b); // true
</code></pre>
<pre><code class="language-js">function changeAgeImpure(person) {
    person.age = 25;
    return person;
}
var alex = {
    name: 'Alex',
    age: 30
};
var changedAlex = changeAgeImpure(alex);

console.log(alex); // -&gt; { name: 'Alex', age: 25 }
console.log(changedAlex); // -&gt; { name: 'Alex', age: 25 }
</code></pre>
<p>원시타입과는 다르게 복사한 것을 변경을 했더니 기존 객체에도 영향이 간다. 이유는 <strong>같은 값의 주소</strong>를 복사했기 때문이다.</p>
<hr />
<a class="header" href="#-reference-1" id="-reference-1"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/B_Type.md">ImD/Dev-Docs - javascript Type</a></li>
</ul>
<a class="header" href="#명시적-변환-vs-암묵적-변환" id="명시적-변환-vs-암묵적-변환"><h2>명시적 변환 vs 암묵적 변환</h2></a>
<p><code>Number(value)</code> 와 같은 코드를 작성하여 변환할 의사를 명확하게 표현하는 것을 <strong>명시적 변환</strong>이라고 한다. <code>JavaScript</code>는 동적 타입 언어이므로 값을 자동으로 여러 유형간에 변환을 자동으로 한다. 이것을 <strong>암묵적 변환</strong> 이라고 한다.</p>
<p>암묵적 변환을 하지 않는 연산자는 <code>===</code> 이며, 완전 항등 연산자 라고 한다. 반면에 느슨한 항등 연산자 <code>==</code> 는 필요하다면 비교와 타입 강제 변환을 수행한다.</p>
<a class="header" href="#string-변환" id="string-변환"><h3>String 변환</h3></a>
<pre><code class="language-js">String(123) // 명시적
123 + ''    // 암시적
</code></pre>
<pre><code class="language-js">String(123)                   // '123'
String(-12.3)                 // '-12.3'
String(null)                  // 'null'
String(undefined)             // 'undefined'
String(true)                  // 'true'
String(false)                 // 'false'
</code></pre>
<p><code>Symbol</code> 변환은 명시적으로만 변환될 수 있고, <strong>암시적 변환은 되지 않는다</strong>.</p>
<pre><code class="language-js">String(Symbol('my symbol'))   // 'Symbol(my symbol)'
'' + Symbol('my symbol')      // TypeError is thrown
</code></pre>
<a class="header" href="#boolean-변환" id="boolean-변환"><h3>Boolean 변환</h3></a>
<pre><code class="language-js">Boolean(2)          // 명시적
if (2) { ... }      // 논리적 문맥 때문에 암시적
!!2                 // 논리적 문맥 때문에 암시적
2 || 'hello'        // 논리적 문맥 때문에 암시적
</code></pre>
<p>논리 연산자(예 : <code>||</code> 및 <code>&amp;&amp;</code> )에 따른 Boolean 변환을 내부적으로 수행하지만 Boolean값이 아니더라도 원래 피연산자의 값을 실제로 반환한다.</p>
<pre><code class="language-js">// true를 반환하는 것이 아닌 123를 반환하고 있다.
// 'hello' and 123 은 표현식을 계산하기 위해서 Boolean으로 강제 변환을 한다.
let x = 'hello' &amp;&amp; 123;   // 123
</code></pre>
<pre><code class="language-js">Boolean('')           // false
Boolean(0)            // false     
Boolean(-0)           // false
Boolean(NaN)          // false
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(false)        // false
</code></pre>
<p><code>object</code>, <code>function</code>, <code>Array</code>, <code>Date</code>, 사용자 정의 유형등은 <code>true</code> 로 변환한다.</p>
<pre><code class="language-js">Boolean({})             // true
Boolean([])             // true
Boolean(Symbol())       // true
!!Symbol()              // true
Boolean(function() {})  // true
</code></pre>
<a class="header" href="#numeric-변환" id="numeric-변환"><h3>Numeric 변환</h3></a>
<p><code>Number()</code> 함수를 사용하면 된다. 암시적 변환은 많은 경우에서 작동이 되기 때문에 까다롭다.</p>
<pre><code class="language-js">Number('123')   // 명시적 - 123
+'123'          // 암시적 - 123
123 != '456'    // 암시적 - true
4 &gt; '5'         // 암시적 - false
5 / null        // 암시적 - Infinity
true | 0        // 암시적 - 1
</code></pre>
<pre><code class="language-js">Number(null) // 0
Number(undefined) // NaN
Number(true)  // 1
Number(false) // 0
Number(&quot; 12 &quot;) // 12
Number(&quot;-12.34&quot;) // -12.34
Number(&quot;\n&quot;) // 0
Number(&quot; 12s &quot;) // NaN
Number(123) // 123
</code></pre>
<ul>
<li>문자열을 숫자로 변환할 때 엔진은 먼저 앞뒤의 공백, <code>\ n</code>, <code>\ t</code> 문자를 제거하고, 문자열이 유효한 숫자를 나타내지 않으면 <code>NaN</code> 을 반환한다. <strong><code>string</code>이 비어 있으면 <code>0</code>을 반환</strong>한다.</li>
<li>null와 undefined는 다르게 처리가 되는데 null은 0으로 undefined는 NaN으로 된다.</li>
</ul>
<p><code>Symbol</code>은 명시적 또는 암시적으로 숫자로 변환될 수 없다. 또한 <code>TypeError</code>는 <code>undefined</code>로 발생하는 것처럼 <code>NaN</code>으로 자동 변환하는 대신 <code>throw</code> 된다.</p>
<pre><code class="language-js">Number(Symbol('my symbol'))    // TypeError is thrown
+Symbol('123')                 // TypeError is thrown
</code></pre>
<a class="header" href="#tips" id="tips"><h4>Tips</h4></a>
<ul>
<li><code>==</code> 를 <code>null</code> 또는 <code>undefined</code> 에 적용하면 숫자 변환이 발생하지 않는다. <code>null</code> 은 <code>null</code>, <code>undefined</code> 와 동일하다.</li>
</ul>
<pre><code class="language-js">null == 0 // false, null is not converted to 0
null == null // true
undefined == undefined // true
null == undefined // true
null === undefined // false
</code></pre>
<ul>
<li><code>NaN</code>은 그 자체가 동등하지 않다.</li>
</ul>
<pre><code class="language-js">var value = NaN;
if (value !== value) { console.log(&quot;we're dealing with NaN here&quot;) }
</code></pre>
<hr />
<a class="header" href="#-reference-2" id="-reference-2"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/B_Type.md">ImD/Dev-Docs - javascript Type</a></li>
</ul>
<a class="header" href="#functional-scope-vs-block-scope" id="functional-scope-vs-block-scope"><h2>Functional Scope vs Block Scope</h2></a>
<a class="header" href="#functional-scope" id="functional-scope"><h2>Functional Scope</h2></a>
<p>자바스크립트는 <strong>함수를 단위로 Scope를 구분한다.</strong> 즉 같은 함수 안에서 선언된 변수들은 같은 레벨의 Scope를 가지게 되는 것이다. 각각의 함수는 독립적인 Scope를 가지게 되어 다른 함수의 Scope에 접근을 할 수 없다.</p>
<pre><code class="language-javascript">// Global Scope
function someFunction() {
  if (true) {
    var name = &quot;BKJang&quot;;
  }
  console.log(name); //BKJang
}
</code></pre>
<p>위와 같이 Global Scope에 <code>someFunction()</code> 을 선언하고 내부에 if문 괄호 안에 선언한 변수는 <strong>someFunction function Scope</strong> 에 붙게 된다. 함수를 단위로 스코프가 생기기 때문에 <code>name</code>을 출력하면 <code>undefined</code>가 아닌 <code>BKJang</code>이 출력된다.</p>
<a class="header" href="#block-scope" id="block-scope"><h2>Block Scope</h2></a>
<p>Block Statement는 우리가 많이 보는 if문, switch문, for, while문이다. 이러한 문장들은 괄호로 감싸진 부분이 존재하지만 새로운 Scope를 만들지는 않는다. Block Statement 안에서 정의한 변수는 가장 가까운 함수의 Scope에 붙게 된다.</p>
<pre><code class="language-javascript">if (true) {
  var name = &quot;BKJang&quot;;
}

console.log(name); // BKJang
</code></pre>
<p><code>ES6</code>에서는 <code>let</code>, <code>const</code>가 추가 되었다. 이 2개는 <code>var</code> 대용으로 사용된다. 그러나 그보다 더 중요한 개념이 들어간다. 바로 <strong>Block Level Scope</strong> 라는 것이다. 기존의 자바스크립트는 위에서 본 것처럼 <strong>Functional Scope</strong> 이다. 그러나 <code>let</code>, <code>const</code> 를 사용하게 되면 <strong>Block Level Scope</strong> 지원이 가능하다.</p>
<pre><code class="language-javascript">if (true) {
  var name = &quot;BKJang&quot;;
  let likes = &quot;Coding&quot;;
  const lang = &quot;Javascript&quot;;
}

console.log(name); // 'BKJang'
console.log(likes); // Uncaught ReferenceError: likes is not defined
console.log(lang); // Uncaught ReferenceError: lang is not defined
</code></pre>
<p><code>var</code>와는 다르게 <code>let</code>, <code>const</code>는 Block Statement내에서 <strong>Local Scope</strong> 를 지원한다. 즉 이제 Scope가 가장 가까운 function에 붙는 것이 아닌 해당 Block에 붙게 되는 것이다.</p>
<p><strong>참고로 Global Scope는 응용 프로그램이 살아있을 때까지 유효하며, Local Scope은 함수가 호출되고 실행되는한 유지가 된다.</strong></p>
<hr />
<a class="header" href="#-reference-3" id="-reference-3"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/B_Function.md">ImD/Dev-Docs - javascript Function</a></li>
<li><a href="https://bkdevlog.netlify.com/posts/let-const">DEVLOG - [ES6]1. let과 const</a></li>
</ul>
<a class="header" href="#javascript의-this" id="javascript의-this"><h2>JavaScript의 this</h2></a>
<p>자바스크립트에서 <code>this</code>의 바인딩은 함수의 호출 방식에 따라 결정된다.</p>
<ul>
<li><strong>객체의 메서드 호출</strong></li>
<li><strong>일반 함수 호출</strong></li>
<li><strong>생성자 함수의 호출</strong></li>
<li><strong><code>call</code>과 <code>apply</code>를 이용한 <code>this</code> 바인딩</strong></li>
<li><strong>ES6의 화살표 함수</strong></li>
</ul>
<a class="header" href="#객체의-메서드-호출" id="객체의-메서드-호출"><h3>객체의 메서드 호출</h3></a>
<pre><code class="language-js">var obj = {
  organization: &quot;Im-D&quot;,
  sayHello: function() {
    return &quot;Welcome to &quot; + this.organization;
  }
};

console.log(obj.sayHello());
</code></pre>
<p>객체의 메서드를 호출할 때 <code>this</code>는 <strong>해당 객체에 바인딩</strong>된다.</p>
<a class="header" href="#일반-함수-호출" id="일반-함수-호출"><h3>일반 함수 호출</h3></a>
<pre><code class="language-js">var organization = &quot;Im-D&quot;;

function sayHello() {
  var organization = &quot;Kyonggi&quot;;
  return &quot;Welcome to &quot; + this.organization;
}

console.log(sayHello());
</code></pre>
<p>일반 함수를 호출할 때, 자바스크립트의 <code>this</code>는 <strong>전역 객체(window 객체)에 바인딩</strong> 된다.</p>
<a class="header" href="#생성자-함수의-호출" id="생성자-함수의-호출"><h3>생성자 함수의 호출</h3></a>
<pre><code class="language-js">function Organization(name, country) {
  this.name = name;
  this.country = country;
}

var imD = new Organization(&quot;Im-D&quot;, &quot;South Korea&quot;);
var kyonggi = Organization(&quot;Kyonggi&quot;, &quot;South Korea&quot;);

console.log(imD);

console.log(kyonggi);
</code></pre>
<p>생성자 함수를 <code>new</code>키워드를 통해 호출할 경우, <strong>새로 생성되는 빈 객체에 바인딩</strong> 된다. 단, <code>new</code>키워드를 사용하지 않으면 <code>this</code>는 전역객체에 바인딩된다.</p>
<a class="header" href="#call-apply-bind를-활용한-this바인딩" id="call-apply-bind를-활용한-this바인딩"><h3><code>call</code>, <code>apply</code>, <code>bind</code>를 활용한 <code>this</code>바인딩</h3></a>
<a class="header" href="#call" id="call"><h4>call</h4></a>
<pre><code class="language-js">function Module(name) {
  this.name = name;
}

Module.prototype.getName = function() {
  const changeName = function() {
    console.log(this);
    return this.name + &quot;입니다.&quot;;
  };
  // return changeName.call(this, 1,2,3,4);
  return changeName.call(this);
};

const module = new Module(&quot;BKJang&quot;);

console.log(module.getName());
</code></pre>
<a class="header" href="#apply" id="apply"><h4>apply</h4></a>
<pre><code class="language-js">function Module(name) {
  this.name = name;
}

Module.prototype.getName = function() {
  const changeName = function() {
    console.log(this);
    return this.name + &quot;입니다.&quot;;
  };

  // return changeName.apply(this, [1,2,3,4]);
  return changeName.apply(this);
};

const module = new Module(&quot;BKJang&quot;);

console.log(module.getName());
</code></pre>
<p>또한 <code>call</code>이나 <code>apply</code>메서드를 활용하여 <strong>유사배열 객체를 일반 배열로 바꿀 수도 있다.</strong></p>
<pre><code class="language-js">function sayHello() {
  console.log(arguments);
  var args = Array.prototype.slice.apply(arguments);
  console.log(args);
}

sayHello(&quot;Im-D&quot;, &quot;South Korea&quot;);
</code></pre>
<p><code>call</code>과 <code>apply</code>는 내부 함수에서 사용할 this를 설정하고 함수 바로 실행까지 해주지만, <code>bind</code>는 <code>this</code>만 설정해주고 함수 실행은 하지 않고 함수를 반환한다.</p>
<pre><code class="language-js">function Module(name) {
  this.name = name;
}

Module.prototype.getName = function() {
  const changeName = function() {
    console.log(this);
    return this.name + &quot;입니다.&quot;;
  };
  let bindChangeName = changeName.bind(this);
  return bindChangeName();
};

const module = new Module(&quot;BKJang&quot;);

console.log(module.getName());
</code></pre>
<a class="header" href="#화살표-함수" id="화살표-함수"><h3>화살표 함수</h3></a>
<pre><code class="language-js">var obj = {
  organization: &quot;Im-D&quot;,
  outerFunc: function() {
    var that = this;
    console.log(this.organization);

    innerFunc = function() {
      console.log(that.organization);
      console.log(this.organization);
    };

    innerFunc();
  }
};

obj.outerFunc();
</code></pre>
<pre><code class="language-js">var obj = {
  organization: &quot;Im-D&quot;,
  outerFunc: function() {
    console.log(this.organization);

    innerFunc = () =&gt; {
      console.log(this.organization);
    };

    innerFunc();
  }
};

obj.outerFunc();
</code></pre>
<p><code>ES5</code>에서는 원래 내부 함수에서의 <code>this</code>는 <code>window</code>객체에 바인딩 되었기 때문에 <code>var that=this;</code>와 같이 선언하여 <code>that</code>에 <code>this</code>를 할당하고 내부 함수에서는 <code>that</code>을 활용하는 방식을 사용했었다.</p>
<p>하지만, <code>ES6</code>에서 등장한 <strong>화살표 함수에서는 this가 무조건 상위 스코프의 this를 가리킨다.</strong>
이에 따라 내부함수에서 <code>var that=this;</code>와 같은 구문을 사용할 필요가 없다.
이처럼 정적으로 <code>this</code>가 바인딩되기 때문에 <strong>Lexical this</strong>라고 한다.</p>
<hr />
<a class="header" href="#-reference-4" id="-reference-4"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://seonhyungjo.github.io/Javascript-Book/Basic/11-Call-Apply-Bind.html">SeonHyungJo - Javascript-Book</a></li>
<li><a href="https://github.com/Im-D/Dev-Docs/edit/master/Javascript/JavaScript%EC%9D%98%20this.md">Im-D/Dev-Docs -Javascript의 this</a></li>
<li><a href="https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb">Zerocho - 자바스크립트의 this는 무엇인가</a></li>
</ul>
<a class="header" href="#prototype" id="prototype"><h2>Prototype</h2></a>
<a class="header" href="#프로토타입-체인" id="프로토타입-체인"><h3>프로토타입 체인</h3></a>
<p>특정 객체의 메서드나 프로퍼티에 접근하고자할 때, <strong>해당 객체에 접근하려고 하는 프로퍼티나 객체가 없다면</strong> 프로토타입 링크([[Prototype]] 프로퍼티)를 따라 <strong>자신의 부모 역할을 하는 프로토타입 객체를 차례로 검색</strong>한다. 이를 프로토타입 체인이라 한다.</p>
<pre><code class="language-javascript">var developer = {
  name: &quot;BKJang&quot;,
  age: 25,
  sex: &quot;male&quot;
};

console.log(developer.hasOwnProperty(&quot;name&quot;)); //true
console.log(developer.__proto__ === Object.prototype); //true
console.log(Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true
</code></pre>
<p><code>developer</code>객체에는 <code>hasOwnProperty()</code>메서드가 존재하지 않지만 에러가 나지 않는다.
이는 <code>developer</code> 객체의 <strong>부모 객체인 <code>Object.prototype</code> 해당 메서드를 검색하기 때문</strong>이다.</p>
<a class="header" href="#객체-리터럴-방식으로-생성했을-때-프로토타입-체인" id="객체-리터럴-방식으로-생성했을-때-프로토타입-체인"><h3>객체 리터럴 방식으로 생성했을 때 프로토타입 체인</h3></a>
<pre><code class="language-javascript">var developer = {
  name: &quot;BKJang&quot;,
  age: 25,
  sex: &quot;male&quot;
};

console.log(developer.__proto__ === Object.prototype); //1.true
console.log(Object.prototype.constructor === Object); // 2.true
console.log(Object.__proto__ === Function.prototype); //3.true
console.log(Function.prototype.__proto__ === Object.prototype); //4.true
</code></pre>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_literal.png" alt="JavaScript" /></p>
<p><code>developer</code> 객체와 <code>Function.prototype</code> 객체의 <strong>프로토타입 객체는 <code>Object.prototype</code> 객체</strong>다.</p>
<blockquote>
<p>객체리터럴 방식으로 객체를 생성하면 해당 객체의 프로토타입 객체는 <code>Object.prototype</code> 객체다.</p>
</blockquote>
<a class="header" href="#생성자-함수를-생성했을-때-프로토타입-체인" id="생성자-함수를-생성했을-때-프로토타입-체인"><h3>생성자 함수를 생성했을 때 프로토타입 체인</h3></a>
<pre><code class="language-javascript">function Developer(name) {
  this.name = name;
}

var web = new Developer(&quot;BKJang&quot;);

console.log(web.__proto__ === Developer.prototype); //1.true
console.log(Developer.prototype.__proto__ === Object.prototype); //2.true
console.log(Developer.prototype.constructor === Developer); //3.true
console.log(Developer.__proto__ === Function.prototype); //4.true
console.log(Function.prototype.__proto__ === Object.prototype); //5.true
</code></pre>
<p><code>Developer.prototype</code> 객체와 Developer() 생성자 함수의 프로토타입 객체인 <code>Function.prototype</code> 객체의 <strong>프로토타입 객체는 <code>Object.prototype</code> 객체</strong>다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_Func.png" alt="JavaScript" /></p>
<a class="header" href="#프로토타입-체인의-종점end-of-prototype-chain" id="프로토타입-체인의-종점end-of-prototype-chain"><h4>프로토타입 체인의 종점(End of prototype chain)</h4></a>
<blockquote>
<p>객체 리터럴 방식으로 객체를 생성하든 생성자 함수를 이용해 객체를 생성하든 <strong>결국 모든 객체의 부모 객체(프로토타입 객체)는 <code>Object.prototype</code> 객체</strong>다. 이 때 <code>Object.prototype</code> 객체를 <strong>프로토타입 체인의 종점</strong>이라 한다.</p>
</blockquote>
<a class="header" href="#프로토타입-객체의-확장" id="프로토타입-객체의-확장"><h3>프로토타입 객체의 확장</h3></a>
<p>프로토타입 객체 역시 객체다. 따라서, 객체의 <strong>프로퍼티를 동적으로 추가하거나 삭제할 수 있다.</strong></p>
<pre><code class="language-javascript">function Developer(name) {
  this.name = name;
}

var web = new Developer(&quot;BKJang&quot;);

web.printAge(25); // Uncaught TypeError: web.printAge is not a function
</code></pre>
<p>위의 코드의 결과를 보면 <strong>web객체에서 <code>printAge()</code>라는 메서드가 없기 때문에</strong> 에러가 나는 것을 볼 수 있다.</p>
<pre><code class="language-javascript">function Developer(name) {
  this.name = name;
}

var web = new Developer(&quot;BKJang&quot;);

Developer.prototype.printAge = function(age) {
  console.log(&quot;The age of this developer is&quot;, age);
};

web.printAge(25); // The age of this developer is 25
</code></pre>
<p>web 객체의 프로토타입 객체(부모 객체)인 <code>Developer.prototype</code> 객체에 <code>printAge(age)</code>라는 메서드를 추가했다.</p>
<p>이에 따라 <strong>web 객체에서 <code>printAge(age)</code>메서드에 접근하면 결과 값을 출력</strong>하는 것을 볼 수 있다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_extenstion.png" alt="JavaScript" /></p>
<a class="header" href="#기본-데이터-타입의-확장" id="기본-데이터-타입의-확장"><h3>기본 데이터 타입의 확장</h3></a>
<p>자바스크립트에서 <strong>숫자, 문자열과 같은 기본 데이터 타입에서 사용되는 표준 메서드의 경우 <code>Number.prototype</code>과 <code>String.prototype</code> 객체에 정의</strong>되어 있다.</p>
<pre><code class="language-javascript">var str = &quot;hello world&quot;;

str.printStr = function(text) {
  console.log(text);
};

str.printStr(&quot;This is the test&quot;); //Uncaught TypeError: str.printStr is not a function
</code></pre>
<p>원시 데이터 타입인 문자열의 경우에는 객체가 아니기 때문에 프로퍼티를 동적으로 추가할 수 없다.</p>
<p>그렇다면, 위에서 <code>str</code>변수에 <code>printStr</code> 메서드를 동적으로 추가하는 코드에서는 왜 에러가 발생하지 않을까?</p>
<p>그 이유는 <strong>기본 데이터 타입으로 프로퍼티나 메소드를 호출하면 기본 데이터 타입과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문</strong>이다.</p>
<pre><code class="language-javascript">var str = &quot;hello world&quot;;

String.prototype.printStr = function(text) {
  console.log(text);
};

str.printStr(&quot;This is the test&quot;); //This is the test
&quot;this is string&quot;.printStr(&quot;This is the test&quot;); //This is the test
</code></pre>
<p>문자열 타입의 경우, <code>String.prototype</code> 객체에 표준 메서드가 정의 되어있기 때문에 <strong>해당 객체에 메서드를 추가해주면 기본 데이터 타입에서도 해당 메서드를 사용할 수 있다.</strong></p>
<pre><code class="language-javascript">var str = &quot;hello world&quot;;

String.prototype.printStr = function(text) {
  console.log(text);
};

console.log(str.__proto__ === String.prototype); //1.true
console.log(String.prototype.__proto__ === Object.prototype); //2.true
console.log(String.prototype.constructor === String); //3.true
console.log(String.__proto__ === Function.prototype); //4.true
console.log(Function.prototype.__proto__ === Object.prototype); //5.true

str.printStr(&quot;This is the test&quot;); //This is the test
</code></pre>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_extenstion_primitive.png" alt="JavaScript" /></p>
<a class="header" href="#프로토타입-객체의-변경" id="프로토타입-객체의-변경"><h3>프로토타입 객체의 변경</h3></a>
<p>자바스크립트에서 특정 객체는 <strong>부모 객체인 프로토타입 객체를 임의로 변경할 수 있다.</strong></p>
<pre><code class="language-javascript">function Developer(name) {
  this.name = name;
}

var web = new Developer(&quot;BKJang&quot;);

Developer.prototype = { age: 25 };

var android = new Developer(&quot;YAKim&quot;);

console.log(web.age); //undefined
console.log(android.age); //25

console.log(web.constructor); //Developer(name)
console.log(android.constructor); //Object()
</code></pre>
<ul>
<li><strong>변경 전 :</strong> 파란색 번호</li>
<li><strong>변경 후 :</strong> 주황색 번호</li>
</ul>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_change.png" alt="JavaScript" /></p>
<p><strong>프로토타입 객체를 변경하기 전,</strong> web객체의 <code>constructor</code>는 프로토타입 체이닝에 따라 <strong><code>Developer()</code>생성자 함수</strong>를 가리킨다.</p>
<p><strong>프로토타입 객체를 변경한 후,</strong> android객체의 <code>constructor</code>는 <strong><code>Object()</code> 함수</strong>를 가리킨다.</p>
<p>프로토타입 객체가 변경되면서 <strong><code>Developer.prototype</code> 객체의 <code>constructor</code> 프로퍼티와 <code>Developer()</code> 생성자 함수의 연결이 깨진다.</strong></p>
<p>이에 따라 <strong>프로토타입 체인이 동작하고</strong> android 객체의 <code>constructor</code>는 <code>Object.prototype</code> 객체의 <code>constructor</code> 프로퍼티가 가리키는 <strong><code>Object()</code> 함수</strong>가 되는 것이다.</p>
<blockquote>
<ul>
<li>프로토타입 객체를 변경하기 전과 후의 프로토타입 링크([[Prototype]] 프로퍼티)는 <strong>각각 다른 프로토타입 객체와 바인딩 된다.</strong></li>
<li>프로토타입 객체를 변경한 후에는 <strong>프로토타입 객체의 constructor 프로퍼티와 생성자 함수와의 연결이 깨진다.</strong></li>
</ul>
</blockquote>
<a class="header" href="#프로토타입-체인의-동작-조건" id="프로토타입-체인의-동작-조건"><h3>프로토타입 체인의 동작 조건</h3></a>
<blockquote>
<p>프로토타입 체인은 객체의 특정 프로퍼티에 접근할 때, 그 프로퍼티가 해당 객체에 없는 경우 동작한다.</p>
</blockquote>
<pre><code class="language-javascript">function Developer(name) {
  this.name = name;
}

Developer.prototype.age = 25;
Developer.prototype.sex = &quot;male&quot;;

var web = new Developer(&quot;BKJang&quot;);
var android = new Developer(&quot;YAKim&quot;);

android.sex = &quot;female&quot;;

console.log(web.age); //1.25
console.log(web.sex); //2.male

console.log(android.age); //1.25
console.log(android.sex); //3.female
</code></pre>
<p><img src="https://bkdevlog.netlify.com/assets/img/prototype_chaining_condition.png" alt="JavaScript" /></p>
<ol>
<li>
<p><code>web</code> 객체에는 <code>age</code>와 <code>sex</code> 프로퍼티가 없기 때문에 <strong>프로토타입 체인에 따라 <code>Developer.prototype</code> 객체의 <code>age</code>와 <code>sex</code> 프로퍼티에 접근</strong>하고 있다.</p>
</li>
<li>
<p><code>android</code> 객체에는 <code>age</code> 프로퍼티는 없지만 <code>sex</code> 프로퍼티는 있기 때문에 <strong><code>sex</code> 프로퍼티의 경우엔 프로토타입 체인이 동작하지 않고 <code>android</code> 객체의 <code>sex</code> 프로퍼티 값을 반환</strong>하고 있다.</p>
</li>
</ol>
<hr />
<a class="header" href="#-reference-5" id="-reference-5"><h4>🙏 Reference</h4></a>
<ul>
<li>인사이드 자바스크립트 (송형주, 고형준)</li>
<li><a href="https://poiemaweb.com/js-prototype">Poiemaweb - Prototype</a></li>
</ul>
<a class="header" href="#실행-컨텍스트" id="실행-컨텍스트"><h2>실행 컨텍스트</h2></a>
<p>실행 컨텍스트는 자바스크립트가 동작하는 원리라고 할 수 있다.</p>
<p>쉽게 말하면, <strong>코드가 실행되는 환경</strong>이라고 보면 된다.</p>
<ul>
<li>
<p>전역 컨텍스트 생성 후, <strong>함수 호출 시마다 함수 컨텍스트가 생긴다.</strong></p>
</li>
<li>
<p>컨텍스트 생성 시 컨텍스트 안에 <code>변수객체(arguments, variable)</code>, <code>scope chain</code>, <code>this</code>가 생성된다.</p>
</li>
<li>
<p>컨텍스트 생성 후 함수가 실행되는데, <strong>사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾는다.</strong></p>
</li>
<li>
<p><strong>함수 실행이 끝나면 해당 컨텍스트는 사라지고, 페이지가 종료되면 전역 컨텍스트는 사라진다.</strong></p>
</li>
</ul>
<a class="header" href="#실행-컨텍스트-스택" id="실행-컨텍스트-스택"><h3>실행 컨텍스트 스택</h3></a>
<p>코드가 실행 될 때, <strong>실행 컨텍스트 스택(Stack)</strong> 이 생성하고 소멸한다.</p>
<p>현재 <strong>실행 중인 컨텍스트에서 관련없는 코드(예를 들어, 다른 함수)가 실행되면 새로운 컨텍스트가 생성</strong>된다.</p>
<pre><code class="language-js">var global = &quot;global&quot;;

function foo() {
  var local1 = &quot;local1&quot;;

  function bar() {
    var local2 = &quot;local2&quot;;
    console.log(local1, local2, global); //local1 local2 global
  }

  bar();
}

foo();
</code></pre>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_ec_stack.png" alt="JavaScript" /></p>
<a class="header" href="#변수-객체variable-object" id="변수-객체variable-object"><h3>변수 객체(Variable Object)</h3></a>
<p>실행 컨텍스트가 생성되면 자바스크립트 엔진은 <strong>실행에 필요한 여러 정보들을 담을 객체를 생성</strong>한다. 이를 <strong>Variable Object(VO / 변수 객체)</strong> 라고 한다.</p>
<p>변수 객체는 <strong>arguments(인수 정보)</strong> 와 <strong>variable(스코프의 변수)</strong> 을 담고 있고, 전역 컨텍스의 경우와 함수 컨텍스트의 경우에 가리키는 객체가 다르다.</p>
<a class="header" href="#전역-컨텍스트" id="전역-컨텍스트"><h4>전역 컨텍스트</h4></a>
<p>전역 컨텍스트의 경우, 변수 객체는 <code>arguments</code>를 가지지 않는다.</p>
<p>그리고 <strong>변수 객체는 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다.</strong></p>
<p>전역 객체는 전역 변수와 전역 함수를 프로퍼티로 가진다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_global_context.png" alt="JavaScript" /></p>
<a class="header" href="#함수-컨텍스트" id="함수-컨텍스트"><h4>함수 컨텍스트</h4></a>
<p>함수 컨텍스트의 경우, <strong>변수 객체는 Activation Object(AO / 활성 객체)를 가리킨다.</strong></p>
<p>또한, 전역 컨텍스트와 다르게 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 유사 배열 객체 <code>arguments</code>도 가진다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_function_context.png" alt="JavaScript" /></p>
<a class="header" href="#스코프-체인scope-chain" id="스코프-체인scope-chain"><h3>스코프 체인(Scope Chain)</h3></a>
<p>스코프 체인은 <strong>현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 담고 있으며</strong>, 연결 리스트의 형태와 유사하게 생성된다.</p>
<p>이 리스트를 이용해 현재 컨텍스트의 변수와 상위 실행 컨텍스트의 변수에도 접근할 수 있다.</p>
<p>이 리스트는 <strong>현재 실행 컨텍스트의 활성 객체</strong>를 먼저 가리키고 순차적으로 <strong>상위 컨텍스트의 활성 객체</strong>를 가리키고 마지막으로 <strong>전역 객체</strong>를 가리킨다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_scope_chain.png" alt="JavaScript" /></p>
<blockquote>
<p>즉, 스코프 체인은 식별자 중 <strong>변수를 검색하는 것</strong>을 말하고, 변수가 아닌 <strong>객체의 프로퍼티를 검색하는 것</strong>을 프로토타입 체인이라고 한다.</p>
</blockquote>
<hr />
<a class="header" href="#-reference-6" id="-reference-6"><h4>🙏 Reference</h4></a>
<ul>
<li>인사이드 자바스크립트 (송형주, 고형준)</li>
<li><a href="https://poiemaweb.com/js-execution-context">Poiemaweb - 실행 컨텍스트와 자바스크립트의 동작 원리</a></li>
</ul>
<a class="header" href="#클로저closure" id="클로저closure"><h2>클로저(Closure)</h2></a>
<p>클로저는 <a href="basic/./06-execution-context.html">실행 컨텍스트</a>와 밀접한 관련이 있다.</p>
<p>생성된 함수 객체는 <code>[[Scopes]]</code> 프로퍼티를 가지게 된다.</p>
<p><code>[[Scopes]]</code> 프로퍼티는 <strong>함수 객체만이 소유하는 내부 프로퍼티(Internal Property)로서 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정</strong>한다.</p>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_scope_property.png" alt="JavaScript" /></p>
<p>내부 함수의 <code>[[Scopes]]</code> 프로퍼티는 <strong>자신의 실행 환경(Lexical Enviroment)</strong> 과 자신을 포함하는 <strong>외부 함수의 실행 환경과 전역 객체</strong>를 가리킨다.</p>
<p>이 때, 자신을 포함하는 <strong>외부 함수의 실행 컨텍스트가 소멸하여도 <code>[[Scopes]]</code>프로퍼티가 가리키는 외부 함수의 실행 환경(Activation Object)은 소멸하지 않고 참조</strong>할 수 있다. 이것이 <strong>클로저</strong>이다.</p>
<p><br/></p>
<p>외부함수에서 내부함수를 반환하는 코드를 보자.</p>
<pre><code class="language-js">function foo() {
  var x = &quot;variable of outerFunc&quot;;

  function bar() {
    console.log(x);
  }

  return bar;
}

var innerFunc = foo();
innerFunc(); //variable of outerFunc
</code></pre>
<p>위의 코드를 보면 외부함수 <code>foo()</code>에서 <code>bar()</code>를 반환하고 소멸한다.</p>
<p><strong>외부함수 <code>foo()</code>는 실행된 이후, 실행 컨텍스트 스택에서 제거되기 때문에 변수 <code>x</code>도 같이 소멸될 것으로 보인다.</strong> 이에 따라 변수 <code>x</code>에 접근할 방법이 없어 보인다.
하지만 <code>innerFunc()</code>함수를 호출하면 변수 x의 값이 출력되는 것을 볼 수 있다.</p>
<p>이처럼 <strong>클로저는 외부함수(<code>foo()</code>) 밖에서 내부함수(<code>bar()</code>)가 호출되더라도 외부함수의 지역 변수(<code>var x</code>)에 접근할 수 있다.</strong></p>
<p><img src="https://bkdevlog.netlify.com/assets/img/js_closure_scope.png" alt="JavaScript" /></p>
<p>클로저가 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는 이유를 설명한 그림이다.</p>
<p>외부함수인 <code>foo()</code>함수가 종료되면 함수 실행 컨텍스트도 소멸하지만 <strong><code>foo()</code> 함수 실행 컨텍스트의 활성 객체는 유효</strong>하다.</p>
<p>이 때문에 <strong>외부 함수 <code>foo()</code>가 실행이 종료되어도 내부 함수 <code>bar()</code>에서 접근이 가능한 것</strong>이다.</p>
<blockquote>
<p>클로저를 사용하면 <strong>클로저에서의 스코프 체인 접근 방식</strong>, <strong>메모리의 부담</strong> 등의 이유로 성능적인 면과 자원적인 면에서 손해를 볼 수 있다. <br/>그렇기 때문에 좋은 구현을 위해서는 충분한 경험을 쌓을 필요가 있다.</p>
</blockquote>
<a class="header" href="#클로저를-활용한-전역-변수의-사용-억제" id="클로저를-활용한-전역-변수의-사용-억제"><h3>클로저를 활용한 전역 변수의 사용 억제</h3></a>
<p>클로저를 활용한 대표적인 예로 카운터가 있다.
우선, 전역 변수를 사용한 예를 한 번 살펴보자.</p>
<pre><code class="language-js">var counter = 0;

function calculator() {
  return console.log(++counter);
}

calculator(); //1
calculator(); //2
calculator(); //3
</code></pre>
<p>위의 결과는 에상대로 잘 나오고 있지만 전역 변수 <code>counter</code>를 쓰고 있다. <br/>
전역 변수는 <strong>어디서든 접근이 가능하기 때문에 값이 변할 수 있고</strong> 이에 따라 오류를 불러올 수 있다.</p>
<pre><code class="language-js">var outerFunc = (function() {
  var counter = 0;

  function calculater() {
    return console.log(++counter);
  }

  return calculater;
})();

outerFunc(); //1
outerFunc(); //2
outerFunc(); //3
</code></pre>
<p>위의 코드와 같이 클로저를 이용하면 전역 변수의 사용을 줄일 수 있다.</p>
<a class="header" href="#루프-안에서의-클로저-활용" id="루프-안에서의-클로저-활용"><h3>루프 안에서의 클로저 활용</h3></a>
<p>클로저를 활용하는데 있어 주의할 사항에 대해 설명할 때 가장 많이 등장하는게 이 경우다.</p>
<pre><code class="language-js">function count(numberOfCount) {
  for (var i = 1; i &lt;= numberOfCount; i++) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  }
}

count(4);
</code></pre>
<p>보면 알겠지만, 위 코드의 의도는 1초 간격으로 1,2,3,4를 출력하는 것이다. 하지만 결과는 예상과 다르게 <strong>5가 4번 1초 간격으로 출력</strong>된다.</p>
<p>그 이유는 <strong>변수 <code>i</code>는 외부함수의 변수가 아닌 전역변수이고 <code>setTimeout()</code>함수가 실행되는 시점은 <code>count()</code>함수가 종료된 이후</strong>다.
이 때는 이미 <code>i</code>의 값이 5인 상태이다.</p>
<pre><code class="language-js">function count(numberOfCount) {
  for (var i = 1; i &lt;= numberOfCount; i++) {
    (function(j) {
      setTimeout(function() {
        console.log(j);
      }, i * 1000);
    })(i);
  }
}

count(4);
</code></pre>
<p>즉시 실행 함수를 실행시켜 루프의 <code>i</code> 값을 <code>j</code>에 복사하고 <code>setTimeout()</code>함수에서 사용했다.<br/>
이 때 <strong><code>j</code>는 상위스코프의 자유변수이므로 그 값이 유지</strong>된다.</p>
<p>이러한 문제는 자바스크립트의 함수형 스코프로 인해 for 루프의 초기문에서 사용된 변수는 <strong>전역 스코프</strong>를 가지기 때문에 발생한다.</p>
<p>ES6에서는 <code>let</code>을 이용해 <strong>블록 레벨 스코프</strong>를 구현할 수 있다.</p>
<pre><code class="language-js">function count(numberOfCount) {
  for (let i = 1; i &lt;= numberOfCount; i++) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  }
}

count(4);
</code></pre>
<p>첫 번째 코드에서 <code>var</code>를 <code>let</code>으로만 바꿔주면 위의 코드처럼 깔끔하게 구현할 수 있다.</p>
<hr />
<a class="header" href="#-reference-7" id="-reference-7"><h4>🙏 Reference</h4></a>
<ul>
<li>[인사이드 자바스크립트 (송형주, 고형준)]</li>
<li><a href="https://poiemaweb.com/js-closure">Poiemaweb - Closure</a></li>
</ul>
<a class="header" href="#템플릿-리터럴template-literal" id="템플릿-리터럴template-literal"><h2>템플릿 리터럴(Template Literal)</h2></a>
<p>ES6(ECMA Script2015)에서는 새로운 문자열 표기법이 도입됐는데 이것이 <strong>템플릿 리터럴</strong>이다.</p>
<p>템플릿 리터럴을 사용하면 기존 문자열 표기 방법의 불편함을 어느 정도 해결할 수 있다.</p>
<ul>
<li>
<p><strong>템플릿 리터럴은 `(백틱)을 사용</strong>한다.</p>
</li>
<li>
<p>이스퀘이프 시퀀스를 사용하지 않아도 템플릿 리터럴 내의 white space가 그대로 인식된다.</p>
</li>
</ul>
<pre><code class="language-js">//ES5
var str = &quot;Hello.\n My Name is BKJang. \n I'm developer.&quot;;

//ES6
let templateStr = `Hello.
May Name is BKJang
I'm developer.`;

console.log(templateStr);
/*
Hello.
May Name is BKJang
I'm developer.
*/
</code></pre>
<ul>
<li><strong>여러 개의 문자열을 연결할 때는 <code>+</code>연산자를 사용하지 않고 <code>String Interpolation(문자열 인터폴레이션)</code>을 사용</strong>한다.</li>
</ul>
<pre><code class="language-js">let str1 = &quot;Hello&quot;;
let str2 = &quot;World&quot;;
let id = &quot;bkjang&quot;;

//ES5
console.log(str1 + &quot; &quot; + str2); //Hello World

//ES6
console.log(`${str1} ${str2}`); //Hello World

let url = `http://localhost:3000/api/user/${id}`;

console.log(url); //http://localhost:3000/api/user/bkjang
</code></pre>
<pre><code class="language-js">console.log(&quot;1 더하기 2 는 &quot; + (1 + 2) + &quot; 입니다,&quot;);

console.log(`1 더하기 2 는 ${1 + 2} 입니다.`);
</code></pre>
<hr />
<a class="header" href="#-reference-8" id="-reference-8"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://poiemaweb.com/es6-template-literals">템플릿 리터럴</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals">Template literals</a></li>
</ul>
<a class="header" href="#화살표-함수arrow-function" id="화살표-함수arrow-function"><h2>화살표 함수(Arrow Function)</h2></a>
<p><strong>화살표 함수는 <code>function</code> 대신 <code>=&gt;</code>를 사용</strong>함으로써 좀 더 간결하게 함수를 선언할 수 있다.</p>
<p>또한 화살표 함수는 익명 함수로만 사용할 수 있기 때문에 <strong>함수 표현식</strong>을 사용한다.</p>
<pre><code class="language-js">const foo = () =&gt; {...} //매개변수가 없을 때
const foo = x =&gt; {...} //매개변수가 하나일 때
const foo = (x, y) =&gt; {...} //매개변수가 여러 개일 때

const foo = x =&gt; { return x; }
const foo = x =&gt; x; // 함수의 블록이 한줄이라면 중괄호와 return을 생략

const sum = (x, y) =&gt; {
    return x + y;
}

console.log(sum(1, 2)); //3
</code></pre>
<pre><code class="language-js">//ES5
var arr = [&quot;JS&quot;, &quot;Java&quot;, &quot;Go&quot;];
var foo = arr.map(function(element) {
  return { Lang: element };
});

console.log(foo); //[{Lang: &quot;JS&quot;}, {Lang: &quot;Java&quot;}, {Lang: &quot;Go&quot;}]

//ES6
const arr = [&quot;JS&quot;, &quot;Java&quot;, &quot;Go&quot;];
const foo = arr.map(element =&gt; {
  return { Lang: element };
});

console.log(foo); //[{Lang: &quot;JS&quot;}, {Lang: &quot;Java&quot;}, {Lang: &quot;Go&quot;}]
</code></pre>
<a class="header" href="#화살표-함수에서의-this-바인딩" id="화살표-함수에서의-this-바인딩"><h3>화살표 함수에서의 this 바인딩</h3></a>
<p>ES5에서는 <strong>함수의 호출 방식에 따라 this가 동적으로 바인딩</strong>이 이뤄진다.</p>
<p><a href="https://github.com/BKJang/do-you-know-vanilla/issues/7">ES5의 this 바인</a></p>
<p>하지만 화살표 함수에서는 this가 무조건 상위 스코프의 this를 가리킨다.</p>
<p>즉 정적인 방식으로 this가 바인딩이 되는데 이를 <strong>Lexical this</strong> 라고 한다.</p>
<p>위의 소스를 화살표 함수를 이용해서 바꾸면 <code>var that = this;</code>라는 구문을 쓸 필요가 없다.</p>
<pre><code class="language-js">const lang = &quot;Korean&quot;;

const obj = {
  lang: &quot;English&quot;,
  outerFunc() {
    //ES6의 축약 메서드 표현
    console.log(&quot;outerFunc : &quot;, this.lang);

    innerFunc1 = () =&gt; {
      console.log(&quot;innerFunc1 : &quot;, this.lang);

      innerFunc2 = () =&gt; {
        console.log(&quot;innerFunc2 : &quot;, this.lang);
      };

      innerFunc2();
    };

    innerFunc1();
  }
};

obj.outerFunc();

/*
outerFunc : English
innerFunc1 : English
innerFunc2 : Engilsh
*/
</code></pre>
<a class="header" href="#항상-화살표-함수일까" id="항상-화살표-함수일까"><h3>항상 화살표 함수일까?</h3></a>
<p>화살표 함수는 위에서 본 것 처럼 정적으로 this를 바인딩(Lexical this)를 지원하기 때문에 콜백 함수로 쓰기 매우 편하다. 하지만, 주의해서 써야할 경우가 몇 가지 있다.</p>
<a class="header" href="#addeventlistener의-콜백-함수-선언" id="addeventlistener의-콜백-함수-선언"><h3>addEventListener의 콜백 함수 선언</h3></a>
<pre><code class="language-js">const btn = document.getElementById(&quot;submitBtn&quot;);

btn.addEventListener(&quot;click&quot;, () =&gt; {
  console.log(this); //Window
});
</code></pre>
<p>위에서 볼 수 있듯이 <code>addEventListener</code>의 <strong>콜백 함수를 화살표 함수로 선언하면 <code>this</code>는 <code>window</code>에 바인딩되므로 그냥 일반함수를 사용하여 선언</strong>하여야 한다.</p>
<a class="header" href="#객체의-메서드에-선언" id="객체의-메서드에-선언"><h3>객체의 메서드에 선언</h3></a>
<p>객체의 메서드를 선언할 때, <strong>화살표 함수를 쓰면 그 객체에 this가 바인딩되지 않고 전역(window)에 바인딩</strong>된다.</p>
<pre><code class="language-js">var lang = &quot;Korean&quot;;

const obj = {
  lang: &quot;English&quot;,
  foo: () =&gt; {
    console.log(&quot;outerFunc : &quot;, this.lang);
  }
};

obj.foo(); //outerFunc : Korean
</code></pre>
<p>위에선 English가 나온다고 생각할 수도 있다. <br/>하지만, <code>foo</code> 선언할 때 화살표 함수를 사용했고 이에 따라 <strong>상위 컨텍스트인 <code>window</code>에 <code>this</code>가 바인딩</strong> 되기 때문에 결과는 Korean이 나온다.</p>
<p>따라서 원하는 결과가 English라면 축약 메서드 표현법으로 정의하는 것이 맞다.</p>
<pre><code class="language-js">var lang = &quot;Korean&quot;;

const obj = {
  lang: &quot;English&quot;,
  foo() {
    console.log(&quot;outerFunc : &quot;, this.lang);
  }
};

obj.foo(); //outerFunc : English
</code></pre>
<a class="header" href="#프로토타입-객체의-메서드-선언" id="프로토타입-객체의-메서드-선언"><h3>프로토타입 객체의 메서드 선언</h3></a>
<p>프로토타입 객체에 메서드를 화살표 함수로 정의하면 객체의 메서드에 화살표 함수로 선언할 때와 같이 <strong><code>this</code>가 <code>window</code>에 바인딩</strong>된다.</p>
<pre><code class="language-js">const devleoper = {
  name: &quot;BKJang&quot;
};

Object.prototype.renderData = () =&gt; console.log(this.name);

devleoper.renderData(); //undefined
</code></pre>
<a class="header" href="#생성자-함수-선언" id="생성자-함수-선언"><h3>생성자 함수 선언</h3></a>
<p>결론부터 말하면, <strong>화살표 함수는 <code>prototype</code> 프로퍼티를 갖고 있지 않다.</strong> 따라서 생성자 함수를 선언할 때 화살표 함수를 쓰면 인스턴스를 생성할 수 없다.</p>
<pre><code class="language-js">const Person = name =&gt; {
  this.name = name;
};

const jang = new Person(&quot;BKJang&quot;); //Uncaught TypeError: Person is not a constructor
</code></pre>
<a class="header" href="#spread연산자--rest파라미터" id="spread연산자--rest파라미터"><h2>Spread연산자 &amp; rest파라미터</h2></a>
<a class="header" href="#rest-파라미터" id="rest-파라미터"><h3>rest 파라미터</h3></a>
<p>rest 파라미터는 Spread 연산자(<code>...</code>)를 사용하여 파라미터를 정의한다.
기존에 ES5에서는 가변 파라미터를 정의할 때 <code>arguments</code>객체를 사용할 수 있었지만 이를 <code>rest 파라미터</code>로 대체할 수 있다.</p>
<pre><code class="language-js">//ES5
function foo() {
  console.log(Array.isArray(arguments));
  console.log(arguments);
}

foo(1, 2, 3, 4, 5);
/*
false
{'0': 1, '1': 2, '2': 3, '3': 4, '4': 5, length: 5}
*/
</code></pre>
<pre><code class="language-js">//ES6
function foo(...rest) {
  console.log(Array.isArray(rest));
  console.log(rest);
}

foo(1, 2, 3, 4, 5);
/*
true
[1, 2, 3, 4, 5]
*/
</code></pre>
<p>위의 결과를 보면 arguments 객체와 rest 파라미터의 중요한 차이를 알 수 있다.</p>
<p><strong><code>arguments</code>객체는 유사배열 객체</strong>다. 따라서 <code>Array.isArray(arguments)</code>의 결과는 false를 반환한다.</p>
<p>여기서 큰 차이가 발생하는데 <strong>유사배열객체는 배열의 메서드를 사용할 수 없다.</strong> 배열의 메서드를 사용하기 위해서는 이를 <strong>배열로 변환하는 과정을 거쳐야하는 불편함</strong>이 있다. <br/>
하지만 가변 인자 함수를 rest 파라미터로 정의하면 파라미터는 배열의 형태로 넘어온다.</p>
<p>또한 ES6의 <a href="https://bkjang.github.io/arrow_function/">화살표 함수(Arrow Function)</a>에서는 <code>arguments</code>를 사용할 수 없다.</p>
<pre><code class="language-js">//ES6 화살표 함수
const foo = () =&gt; {
  console.log(arguments);
};

foo(1, 2, 3, 4, 5); //Uncaught ReferenceError: arguments is not defined
</code></pre>
<blockquote>
<ul>
<li><code>rest</code> 파라미터는 <code>arguments</code>와 달리 <strong>배열</strong>로 파라미터가 넘어온다.</li>
<li>ES6의 <strong>화살표 함수에서는 <code>arguments</code>를 사용할 수 없다.</strong></li>
</ul>
</blockquote>
<a class="header" href="#spread-연산자" id="spread-연산자"><h3>Spread 연산자</h3></a>
<p>Spread 연산자는 말그대로 전개 연산자다. <strong>배열 또는 Iterable object(반복 가능한 객체)의 엘리먼트를 하나씩 분리하여 전개</strong>한다.</p>
<pre><code class="language-js">let a = &quot;Hello&quot;;
let arr = [...a];

console.log(arr); //[&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
</code></pre>
<a class="header" href="#spread-연산자의-활용" id="spread-연산자의-활용"><h3>Spread 연산자의 활용</h3></a>
<ul>
<li><strong>concat</strong></li>
</ul>
<p>ES5에서는 배열을 합칠 때 <code>concat</code>을 사용했었다. 이를 <code>Spread</code>연산자로 대체할 수 있다.</p>
<pre><code class="language-js">//concat
var arr1 = [5, 6];
var arr2 = [1, 2, 3, 4];

console.log(arr2.concat(arr1)); //[1, 2, 3, 4, 5, 6]
console.log(arr1.concat(arr2)); //[5, 6, 1, 2, 3, 4]
</code></pre>
<pre><code class="language-js">//ES6 Spread Operator
let arr1 = [5, 6];
let arr2 = [1, 2, 3, 4, ...arr1];

console.log(arr2); //[1, 2, 3, 4, 5, 6]
console.log([1, 2, ...arr1, 3, 4]); //[1, 2, 5, 6, 3, 4]
</code></pre>
<p>단순히 앞, 뒤에 배열의 요소를 붙이는데는 <code>concat</code>이 성능이 더 좋다. 하지만 중간에 특정 배열의 값을 추가하고 싶다면 <code>Spread</code>연산자를 사용하는 것도 좋은 방법이다.</p>
<ul>
<li><strong>split</strong></li>
</ul>
<p>문자열을 배열로 변환할 때 많이 쓰이는 함수가 <code>split()</code>이다. 이 또한 Spread 연산자를 활용하면 좀 더 편하게 변환할 수 있다.</p>
<pre><code class="language-js">//split

var a = &quot;Hello&quot;;
var arr = a.split(&quot;&quot;);

console.log(arr); //[&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
</code></pre>
<pre><code class="language-js">//ES6 Spread Operator

let a = &quot;Hello&quot;;
let arr = [...a];

console.log(arr); //[&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
</code></pre>
<ul>
<li><strong>함수의 인자로 사용</strong></li>
</ul>
<p>기존에 ES5에서는 배열의 각 요소를 개별적인 파라미터로 전달하고 싶은 경우, <code>Function.prototype.apply</code>를 사용하는 것이 일반적이었다. <br/>하지만 ES6의 <code>Spread</code> 연산자를 활용하여 함수의 인자에 들어가는 배열을 개별요소로 전달할 수 있다.</p>
<pre><code class="language-js">//ES5 apply
var arr = [1, 2, 3];

function sum(a, b, c) {
  console.log(a, b, c); //1 2 3
  return a + b + c;
}

console.log(sum.apply(null, arr)); //6
</code></pre>
<pre><code class="language-js">//ES6 Spread Operator
let arr = [1, 2, 3];

const sum = (a, b, c) =&gt; a + b + c;

console.log(sum(...arr)); //6
</code></pre>
<ul>
<li><strong>객체에서 사용</strong></li>
</ul>
<p>객체는 Iterable Object아니지만 Spread 연산자를 사용하면 객체를 손쉽게 병합 또는 변경할 수 있다.</p>
<pre><code class="language-js">let obj1 = {
  name: &quot;BKJang&quot;,
  job: &quot;Developer&quot;
};

let obj2 = {
  ...obj1,
  lang: &quot;Korean&quot;
};

console.log(obj2); //{name: &quot;BKJang&quot;, job: &quot;Developer&quot;, lang: &quot;Korean&quot;}
</code></pre>
<p>Spread 연산자를 활용하면 유사배열객체(arguments, HTMLCollection 등)를 배열로 변환하기도 편하다.</p>
<pre><code class="language-js">function foo() {
  let args = arguments;
  let arr = [...args];

  console.log(Array.isArray(args)); //false
  console.log(Array.isArray(arr)); //true
  console.log(arr); //
}

foo(1, 2, 3, 4, 5); //[1, 2, 3, 4, 5]
</code></pre>
<hr />
<a class="header" href="#-reference-9" id="-reference-9"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN Web Docs - Spread 문법</a></li>
<li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/">[ES6] 4. Spread, Rest parameter</a></li>
<li><a href="https://poiemaweb.com/es6-extended-parameter-handling">파라미터 기본값, Rest 파라미터, Spread 연산자</a></li>
</ul>
<a class="header" href="#destructuring비구조화-할당" id="destructuring비구조화-할당"><h2>Destructuring(비구조화 할당)</h2></a>
<p>디스트럭처링은 <strong>구조화된 배열 혹은 객체를 분해하여 변수에 할당</strong>하는 방식이다. 이 개념을 몰랐더라도 <code>React</code>를 사용해봤던 개발자라면 아마 많이 봤을 문법이다.</p>
<pre><code class="language-js">const { state } = this.props;
</code></pre>
<p>오른쪽의 특정 값을 해체하여 왼쪽에 할당하는 표현식을 **<code>Destructuring Assignment</code>**라고 한다.</p>
<a class="header" href="#배열-디스트럭처링" id="배열-디스트럭처링"><h3>배열 디스트럭처링</h3></a>
<pre><code class="language-js">//ES5
var arr = [&quot;JS&quot;, &quot;Java&quot;, &quot;Node.js&quot;];

var x = arr[0];
var y = arr[1];
var z = arr[2];

console.log(x, y, z); //JS Java Node.js
</code></pre>
<pre><code class="language-js">//ES6
const arr = [&quot;JS&quot;, &quot;Java&quot;, &quot;Node.js&quot;];

let [x, y, z] = arr;

console.log(x, y, z); //JS Java Node.js
</code></pre>
<pre><code class="language-js">const numArr = [1, 2, 3, 4];

let [x, y, , z] = numArr;

console.log(x, y, z); //1 2 4
</code></pre>
<p>위의 결과를 보면 알 수 있듯이 배열을 디스트럭처링하면 각각의 변수에 배열의 <code>index</code>를 기준으로 할당된다.</p>
<p>디스트럭처링을 사용했을 때 편한 대표적인 예는 <strong>변수의 swap처리</strong>를 할 때다.</p>
<pre><code class="language-js">//ES5(For Swap)
var x = 1;
var y = 2;
var tmp = y;

console.log(x, y); //1 2

y = x;
x = tmp;

console.log(x, y); //2 1
</code></pre>
<pre><code class="language-js">//ES6
let x = 1;
let y = 2;

console.log(x, y); //1 2

[x, y] = [y, x];

console.log(x, y); //2 1
</code></pre>
<a class="header" href="#객체-디스트럭처링" id="객체-디스트럭처링"><h3>객체 디스트럭처링</h3></a>
<p>객체 또한 디스트럭처링이 가능하며 배열과 크게 다르지 않다.</p>
<pre><code class="language-js">//ES5
var obj = { name: &quot;BKJang&quot;, lang: &quot;Korean&quot;, job: &quot;Developer&quot; };

var name = obj.name;
var lang = obj.lang;
var job = obj.job;

console.log(name, lang, job); //BKJang Korean Developer
</code></pre>
<pre><code class="language-js">//ES6
const obj = { name: &quot;BKJang&quot;, lang: &quot;Korean&quot;, job: &quot;Developer&quot; };

let { name, lang, job } = obj;

console.log(name, lang, job); //BKJang Korean Developer
</code></pre>
<p>만약 변수 명을 다르게 하고 싶다면 다음과 같이 처리하면 된다.</p>
<pre><code class="language-js">var obj = { a: 1, b: &quot;hello&quot; };
var { a: key, b: value } = obj;

console.log(key, value); // 1, 'hello'
</code></pre>
<p>중첩 객체의 경우에는 아래와 같이 사용한다.</p>
<pre><code class="language-js">const developer = {
  name: &quot;BKJang&quot;,
  stack: {
    front: &quot;HTML / CSS / JS&quot;,
    back: &quot;Java / Node.js&quot;
  }
};

const {
  name,
  stack: { front }
} = developer;

console.log(name, front); //BKJang HTML / CSS / JS
</code></pre>
<p>디스트럭처링을 사용하면 **기본 값(Default Value)**이나 **기본 파라미터(Default Parameter)**를 세팅할 수 있고, <a href="https://bkdevlog.netlify.com/posts/spread-rest">Speread Operator</a>또한 사용할 수도 있다.</p>
<a class="header" href="#spread-operator-용" id="spread-operator-용"><h3>Spread Operator 용</h3></a>
<pre><code class="language-js">const arr = [1, 2, 3, 4];

let [x, y, ...z] = arr;

console.log(x, y, z); //1 2 [3, 4]
</code></pre>
<pre><code class="language-js">const obj = { one: 1, two: 2, three: 3, four: 4 };

let { one, two, ...rest } = obj;

console.log(one, two, rest); //1 2 {three: 3, four: 4}
</code></pre>
<a class="header" href="#기본-값default-value" id="기본-값default-value"><h3>기본 값(Default Value)</h3></a>
<pre><code class="language-js">const arr = [1, 2];

let [x, y, z = 3] = arr;

console.log(x, y, z); //1 2 3
</code></pre>
<pre><code class="language-js">const obj = { one: 1, two: 2 };

let { one, two, three = 3 } = obj;

console.log(one, two, three); //1 2 3
</code></pre>
<a class="header" href="#기본-파라미터default-parameter" id="기본-파라미터default-parameter"><h3>기본 파라미터(Default Parameter)</h3></a>
<pre><code class="language-js">const doSomething = (name, stack = &quot;FrontEnd&quot;) =&gt; {
  stack = stack === null ? &quot;FullStack&quot; : stack;

  console.log(`${name}은 ${stack}개발자입니다.`);
};

doSomething(&quot;BKJang&quot;); //BKJang은 FrontEnd개발자입니다.
doSomething(&quot;BKJang&quot;, &quot;BackEnd&quot;); //BKJang은 BackEnd개발자입니다.
doSomething(&quot;BKJang&quot;, undefined); //BKJang은 FrontEnd개발자입니다.
doSomething(&quot;BKJang&quot;, null); //BKJang은 FullStack개발자입니다.

//Default Parameter는 함수의 length에 포함되지 않는다.
console.log(doSomething.length); //1
</code></pre>
<p>자바스크립트에서 함수는 <code>length</code>프로퍼티를 가지는데 인자의 갯수를 나타낸다.
<strong><code>Default Parameter</code>는 이 <code>length</code>프로퍼티에 포함되지 않는다.</strong></p>
<hr />
<a class="header" href="#-reference-10" id="-reference-10"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN Web Docs - 구조 분해 할당</a></li>
<li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/">[ES6] 5. Destructuring and Default Parameter</a></li>
<li><a href="https://poiemaweb.com/es6-destructuring">Destructuring 디스트럭처링</a></li>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/ECMAScript/Destructuring_Assignment.md">ImD/Dev-Docs - Destructuring_Assignment</a></li>
</ul>
<a class="header" href="#클래스class" id="클래스class"><h2>클래스(class)</h2></a>
<p><code>ES6</code>에서부터는 <code>ES5</code>까지는 존재하지 않았던 <code>class</code>가 생겨났다. <code>Java</code>에서의 <code>Class</code>와는 똑같은 기능을 한다고 생각해서는 안된다.
<strong>자바스크립트는 기본적으로 <code>Prototype</code>기반의 객체지향 언어</strong>다. 즉, <code>ES6</code>의 <code>Class</code>또한 프로토타입을 기반으로 동작하며 이는 기존의 자바스크립트에서 객체지향적으로 설계할 때의 방식을 좀 더 편하게 보완한 <code>Syntatic Sugar</code>다.</p>
<a class="header" href="#클래스의-정의" id="클래스의-정의"><h3>클래스의 정의</h3></a>
<pre><code class="language-js">//ES5
var Person = (function() {
  //생성자 함수 정의
  function Person(name, job) {
    this.name = name;
    this.job = job;
  }

  Person.prototype.sayInfo = function() {
    console.log(&quot;Name : &quot; + this.name + &quot;, Job : &quot; + this.job);
  };

  return Person;
})();

var bkJang = new Person(&quot;BKJang&quot;, &quot;Developer&quot;);

bkJang.sayInfo(); //Name : BKJang, Job : Developer
</code></pre>
<p><code>ES6</code>에서 <code>Class</code>가 생기기 전 우리는 위와 같은 방식으로 생성자 함수와 프로토타입을 이용해 객체지향 프로그래밍을 진행했었다. 위와 같은 코드를 <code>ES6</code>의 <code>Class</code>를 사용하여 구현하면 아래와 같이 좀 더 간결하게 구현할 수 있다.</p>
<pre><code class="language-js">//ES6
class Person {
  constructor(name, job) {
    this.name = name;
    this.job = job;
  }

  sayInfo() {
    console.log(`Name : ${this.name}, Job : ${this.job}`);
  }
}

const bkJang = new Person(&quot;BKJang&quot;, &quot;Developer&quot;);

bkJang.sayInfo(); //Name : BKJang, Job : Developer
</code></pre>
<p>클래스는 기본적으로 위와 같이 <strong><code>Class Person {}l</code>으로 정의하며, 흔치는 않지만 <code>const Person = class MyClass {};</code>처럼 함수 표현식으로도 정의 가능</strong>하다.</p>
<p>둘의 또 다른 차이점은 생성자 함수를 이용하여 선언하면 <code>window</code>에 할당되지만, <strong><code>Class</code>를 이용하여 선언하면 <code>window</code>에 할당되지 않는다.</strong></p>
<p>또한 <strong><code>Class</code> 안에 있는 코드는 항상 <code>strict mode</code> 로 실행</strong>되기 때문에 &quot;use strict&quot; 명령어가 없더라도 동일하게 동작한다.</p>
<pre><code class="language-js">function Person() {}
class Developer {}

console.log(window.Person); //ƒ Person() {}
console.log(window.Developer); //undefined
</code></pre>
<a class="header" href="#인스턴스의-생성과-호이스팅" id="인스턴스의-생성과-호이스팅"><h3>인스턴스의 생성과 호이스팅</h3></a>
<p><code>Class</code>를 사용하여 인스턴스를 생성할 때는 반드시 <code>new</code>를 이용해 호출해야하며 <code>new</code>를 사용하지 않으면 <code>Type Error</code>가 발생한다.</p>
<pre><code class="language-js">class Foo {}

const foo = Foo(); //Uncaught TypeError: Class constructor Foo cannot be invoked without 'new'
</code></pre>
<p><code>ES6</code>의 <code>Class</code>는 <a href="https://bkdevlog.netlify.com/posts/let-const">let, const</a>와 마찬가지로 호이스팅이 일어나지만, <strong>선언이 일어나고 할당이 이뤄지기 전 <code>TDZ(Temporary Dead Zone)</code>에 빠지기 때문에 할당 이전에 호출하면 <code>Reference Error</code>가 발생</strong>한다.</p>
<pre><code class="language-js">const foo = new Foo(); //Uncaught ReferenceError: Foo is not defined

class Foo {}
</code></pre>
<a class="header" href="#constructor" id="constructor"><h3>constructor</h3></a>
<p><code>constructor</code>는 인스턴스를 생성하고 <code>Class</code>의 <code>property</code>를 초기화한다. <code>ES5</code>에서는 생성자 함수를 이용해 <code>property</code>를 초기화하고 <strong>생성자 함수를 반환</strong>함으로써 객체지향을 구현했었다.</p>
<ul>
<li><strong>class는 constructor를 반환하며 생략할 수 있다.</strong></li>
</ul>
<p><code>const foo = new Foo()</code>와 같이 선언했을 때 <code>Foo</code>는 <code>class</code>명이 아닌 <code>constructor</code>다.</p>
<pre><code class="language-js">class Foo {}

const foo = new Foo();

console.log(Foo == Foo.prototype.constructor); //true
</code></pre>
<p>위의 코드에서 볼 수 있듯이 <code>new</code>와 함께 호출한 <code>Foo</code>는 <code>constructor</code>와 같음을 확인할 수 있다.</p>
<p>또 확인할 수 있는 것은 <code>class Foo</code>내부에 <code>constructor</code>를 선언하지 않았음에도 인스턴스의 생성이 잘 이뤄지는 것을 볼 수 있다.
이는 <strong><code>Class</code>내부에 <code>constructor</code>는 생략할 수 있으며 생략하면 <code>Class</code>에 <code>constructor() {}</code>를 포함한 것과 동일하게 동작</strong>하기 때문이다.
즉, 빈 객체를 생성하기 때문에 <code>property</code>를 선언하려면 인스턴스를 생성한 이후, <code>property</code>를 동적 할당해야 한다.</p>
<pre><code class="language-js">console.log(foo); //Foo {}

foo.name = &quot;BKJang&quot;;

console.log(foo); //Foo {name: &quot;BKJang&quot;}
</code></pre>
<ul>
<li><strong>class의 property는 constructor 내부에서 선언과 초기화가 이뤄진다.</strong></li>
</ul>
<p><code>class</code>의 몸체에는 메서드만 선언 가능하며, <code>property</code>는 <code>constructor</code>내부에서 선언하여야 한다.</p>
<pre><code class="language-js">class Foo {
  name = &quot;&quot;; //Syntax Error
}
</code></pre>
<pre><code class="language-js">class Bar {
  constructor(name = &quot;&quot;) {
    this.name = name;
  }
}

const bar = new Bar(&quot;BKJang&quot;);
console.log(bar); //Bar {name: &quot;BKJang&quot;}
</code></pre>
<blockquote>
<p><code>constructor</code>내부에서 선언한 <code>property</code>는 <code>Class</code>의 인스턴스를 가리키는 <code>this</code>에 바인딩 된다.</p>
</blockquote>
<a class="header" href="#getter-setter" id="getter-setter"><h3>getter, setter</h3></a>
<p><code>class</code>의 프로퍼티에 접근하기 위한 인터페이스로서, <code>getter</code>와 <code>setter</code>를 정의할 수 있다.</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name;
  }

  //getter
  get personName() {
    return this.name ? this.name : null;
  }

  //setter
  set personName(name) {
    this.name = name;
  }
}

const person = new Person(&quot;BKJang&quot;);

console.log(person.personName); //BKJang
person.personName = &quot;SHJo&quot;;
console.log(person.personName); //SHJo
</code></pre>
<a class="header" href="#static-메서드" id="static-메서드"><h3>Static 메서드</h3></a>
<p><code>class</code>에서는 정적 메서드를 정의할 때, <code>static</code> 키워드를 사용하여 정의한다. <strong>정적 메서드는 인스턴스를 생성하지 않아도 호출가능하며, 인스턴스가 아닌 <code>Class</code>의 이름으로 호출한다.</strong> 이와 같은 특징 때문에 애플리케이션을 위한 유틸리티성 함수를 생성하는데 주로 사용한다.</p>
<p>또한 정적 메서드 내부에서는 <code>this</code>를 사용할 수 없다. 왜냐하면 <strong>정적 메서드 내부에서는 <code>this</code>가 <code>Class</code>의 인스턴스가 아닌 <code>Class</code>자기 자신을 가리키기 때문</strong>이다.</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name;
  }

  //getter
  get personName() {
    return this.name ? this.name : null;
  }

  //setter
  set personName(name) {
    this.name = name;
  }

  static staticMethod() {
    console.log(this);
    return &quot;This is static&quot;;
  }
}

console.log(Person.staticMethod());
/*
class Person { ... }
This is static
*/

const instance = new Person(&quot;BKJang&quot;);

console.log(instance.staticMethod()); //Uncaught TypeError: instance.staticMethod is not a function
</code></pre>
<p>위에서 볼 수 있듯이 인스턴스로는 <code>Class</code>의 정적 메서드를 호출할 수 없다.</p>
<p>또한 <strong>정적 메서드는 <code>prototype</code>에 추가되지 않는다.</strong></p>
<pre><code class="language-js">console.log(Person.staticMethod === Person.prototype.staticMethod); //false
console.log(new Person().personName === Person.prototype.personName); //true
</code></pre>
<a class="header" href="#클래스의-상속" id="클래스의-상속"><h3>클래스의 상속</h3></a>
<p><code>class</code>를 이용하여 <code>OOP</code>의 특징 중 하나인 상속을 구현할 수 있다.
<code>class</code>의 상속을 위해서는 <code>extends</code>와 <code>super</code> 키워드에 대해서 알아야 한다.</p>
<pre><code class="language-js">class Person {
  constructor(name, sex) {
    this.name = name;
    this.sex = sex;
  }

  getInfo() {
    return `Name : ${this.name}, Sex : ${this.sex}`;
  }

  getName() {
    return `Name : ${this.name}`;
  }

  getSex() {
    return `Sex : ${this.sex}`;
  }
}

class Developer extends Person {
  //extends를 사용하여 Person 클래스 상속
  constructor(name, sex, job) {
    //super메서드를 사용하여 부모 클래스의 인스턴스를 생성
    super(name, sex);
    this.job = job;
  }

  //오버라이딩
  getInfo() {
    //super 키워드를 사용하여 부모 클래스에 대한 참조
    return `${super.getInfo()} , Job: ${this.job}`;
  }

  getJob() {
    return `Job : ${this.job}`;
  }
}

const person = new Person(&quot;SHJo&quot;, &quot;Male&quot;);
const developer = new Developer(&quot;BKJang&quot;, &quot;Male&quot;, &quot;Developer&quot;);

console.log(person); //Person {name: &quot;SHJo&quot;, sex: &quot;Male&quot;}
console.log(developer); //Developer {name: &quot;BKJang&quot;, sex: &quot;Male&quot;, job: &quot;Developer&quot;}

console.log(person.getInfo()); //Name : SHJo, Sex : Male

console.log(developer.getName()); //Name : BKJang
console.log(developer.getSex()); //Sex : Male
console.log(developer.getJob()); //Job : Developer
console.log(developer.getInfo()); //Name : BKJang, Sex : Male , Job: Developer

console.log(developer instanceof Developer); //true
console.log(developer instanceof Person); //true
</code></pre>
<p>위의 소스를 기준으로 중요한 특징을 정리하자면 다음과 같다.(대부분의 객체 지향 언어에서 상속의 특징과 거의 동일하다.)</p>
<ul>
<li>
<p><strong>부모 클래스(슈퍼 클래스)의 메서드를 사용할 수 있다.</strong></p>
</li>
<li>
<p><strong>부모 클래스의 메서드를 오버라이딩(Overriding)할 수 있다.</strong></p>
</li>
<li>
<p><strong><code>super</code> 키워드를 통해 부모 클래스의 메서드에 접근</strong>할 수 있다.</p>
</li>
<li>
<p><strong><code>super</code> 메서드</strong>(위의 Developer 클래스의 constructor내부에 선언)<strong>는 자식 클래스의 <code>constructor</code> 내부에서 부모 클래스의 constructor(<code>super-constructor</code>)를 호출</strong>한다.</p>
</li>
</ul>
<hr />
<a class="header" href="#-reference-11" id="-reference-11"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes">MDN Web Docs - Classes</a></li>
<li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/">[ES6] 6. Class sugar syntax</a></li>
<li><a href="https://poiemaweb.com/es6-class">Class 클래스</a></li>
</ul>
<a class="header" href="#모듈module" id="모듈module"><h2>모듈(Module)</h2></a>
<p>자바스크립트(<code>ES5</code>)에서 기본적으로 모듈 기능이 없다.
기본적으로 자바스크립트에서 <strong>변수는 전역(global)에 할당되기 때문에 모듈을 구현하기 위해서는 <code>Namespace Pattern</code> 혹은 <a href="https://bkdevlog.netlify.com/posts/oop-encapsulation-of-js">Module Pattern</a>과 같은 기법이 필요</strong>했다.</p>
<p>이러한 상황에서 클라이언트 사이드에서뿐만이 아니라 범용적인 사용이 일어나면서 모듈화의 필요성이 대두되었다. 이에 따라 <a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/AMD%EC%99%80%20CommonJS.md">CommonJS와 AMD</a> 이렇게 2개의 진영으로 나뉘게 되었다.
우리가 잘 알고 있는 <code>Node.js</code>는 <code>CommonJS</code>의 모듈화 방식을 따르고 있다.</p>
<p><code>ES6</code>에서는 <strong>클라이언트 사이드에서도 모듈화를 제공하기 위해 <code>export</code>와 <code>import</code>가 추가</strong>되었다.
단, <code>ES6</code>의 모듈 기능은 대부분의 브라우저에서는 지원하지 않기 때문에 <code>RequireJS</code>와 같은 모듈 로더나 <code>Webpack</code>과 같은 모듈 번들러와 함께 <code>babel</code>과 같은 트랜스파일러를 사용하여야 한다.</p>
<a class="header" href="#export" id="export"><h2>export</h2></a>
<p>ES6의 모듈은 보통 <strong>파일 단위</strong>로 구성되며 독립적인 파일 스코프를 가지기 때문에 <strong>외부에서 모듈의 기능을 사용하고 싶다면 위와 같이 <code>export</code>를 해줘야한다.</strong></p>
<pre><code class="language-js">//module.js
export const message = &quot;this is variable&quot;;

export function sayHello() {
  console.log(&quot;Hello World&quot;);
}

export function sayName(name) {
  console.log(`Hi ${name}`);
}

export class Person {
  constructor(name, job) {
    this.name = name;
    this.job = job;
  }
}
</code></pre>
<p>위와 같이 각각의 변수, 함수, 클래스에 <code>export</code>키워드를 붙여 export할 수 있고 아래와 같이 <strong>하나의 객체로 묶어 한 번에 export할 수도 있다.</strong></p>
<pre><code class="language-js">//module.js
const message = &quot;this is variable&quot;;

function sayHello() {
  console.log(&quot;Hello World&quot;);
}

function sayName(name) {
  console.log(`Hi ${name}`);
}

class Person {
  constructor(name, job) {
    this.name = name;
    this.job = job;
  }
}

export { message, sayHello, sayName, Person };
</code></pre>
<a class="header" href="#import" id="import"><h2>import</h2></a>
<p>ES6에서 export한 모듈을 사용하기 위해서는 해당 파일에서 <code>import</code>키워드를 사용하여 가져와 쓰면 된다.</p>
<pre><code class="language-js">import { message, sayHello, sayName, Person } from &quot;./module&quot;;

console.log(message); //this is variable
console.log(sayHello()); //Hello World
console.log(sayName(&quot;BKJang&quot;)); //Hi BKJang
console.log(new Person(&quot;BKJang&quot;, &quot;Developer&quot;)); //Person { name : BKJang, job: Developer }
</code></pre>
<p>위와 같이 각각를 import하지 않고 <strong>한꺼번에 import하거나 이름을 변경하여 import 할 수도 있다.</strong></p>
<pre><code class="language-js">//한꺼번에 묶어서 import
import * as module from &quot;./module&quot;;

console.log(module.sayName(&quot;BKJang&quot;)); //Hi BKJang
</code></pre>
<pre><code class="language-js">//이름을 변경하여 import
import { sayHello as hello } from &quot;./module&quot;;

console.log(hello()); //Hello World
</code></pre>
<a class="header" href="#default" id="default"><h2>default</h2></a>
<p>모듈에서 하나만 export할 경우에는 <code>default</code>키워드를 사용하면 된다.</p>
<pre><code class="language-js">//Person.js
export default class Person {
  constructor(name) {
    this.name = name;
  }
}
</code></pre>
<pre><code class="language-js">//Person.js
class Person {
    //...
}

export default
</code></pre>
<p>이를 import할 때는 <strong><code>{}</code>없이 해당 모듈을 임의의 이름으로 가져와 사용</strong>하면 된다.</p>
<pre><code class="language-js">import Person from &quot;./Person&quot;;
</code></pre>
<hr />
<a class="header" href="#-reference-12" id="-reference-12"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://poiemaweb.com/es6-module">모듈</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import">import(MDN web docs)</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export">export(MDN web docs)</a></li>
</ul>
<a class="header" href="#promise와-async-await" id="promise와-async-await"><h1>Promise와 async-await</h1></a>
<a class="header" href="#iteration-protocol" id="iteration-protocol"><h1>Iteration Protocol</h1></a>
<a class="header" href="#generator" id="generator"><h1>Generator</h1></a>
<a class="header" href="#이벤트-루프event-loop" id="이벤트-루프event-loop"><h2>이벤트 루프(Event Loop)</h2></a>
<a class="header" href="#자바스크립트는-싱글쓰레드-기반이다" id="자바스크립트는-싱글쓰레드-기반이다"><h3>자바스크립트는 싱글쓰레드 기반이다.</h3></a>
<p>자바스크립트를 공부해본 개발자라면 한 번쯤은 <code>자바스크립트는 싱글 쓰레드 기반의 언어다.</code>라는 말을 들어봤을 것이다. 하지만 우리는 실제 웹 애플리케이션에서 여러 개의 작업이 동시에 처리되는 것처럼(비동기적) 느끼는 일이 더 많다. 싱글 쓰레드 기반의 언어에서 즉, 한 번에 하나의 작업만 처리가능한 환경에서 어떻게 많은 작업이 동시에 처리되는 것처럼 느낄 수 있을까? 그 답은 <strong>이벤트 루프</strong>에 있다.</p>
<p>브라우저 환경을 간단히 표현하면 다음 이미지와 같다.</p>
<p><img src="https://github.com/Im-D/Dev-Docs/raw/master/assets/images/event_loop.jpeg" alt="eventLoop" /></p>
<p>우선, 위의 그림에서 보여지는 각각에 대해서 살펴본 후, 전체적으로 이벤트 루프가 동작하는 방식을 살펴보도록 하자.</p>
<a class="header" href="#자바스크립트-엔진" id="자바스크립트-엔진"><h3>자바스크립트 엔진</h3></a>
<a class="header" href="#heap" id="heap"><h4>Heap</h4></a>
<p>동적으로 생성된 객체 인스턴스는 Heap에 할당이 된다. Heap은 메모리에서 대부분 구조화되지 않은 영역을 나타낸다.</p>
<a class="header" href="#call-stack호출-스택" id="call-stack호출-스택"><h4>Call Stack(호출 스택)</h4></a>
<p>호출 스택은 이름 그대로 <code>Stack</code>이며 LIFO(Last-In-First-Out)구조를 갖는다. 함수를 호출하면(작업을 요청하면) 작업은 순차적으로 호출 스택에 쌓이고 실행된다. 자바스크립트 엔진은 하나의 스택만 가지고 있기 때문에 하나의 작업이 끝나기 전까지 다른 작업을 수행할 수 없다.</p>
<a class="header" href="#web-apis" id="web-apis"><h3>Web APIs</h3></a>
<p>흔히 WebAPI라 불리는 API들은 실행환경에 내장되어 있다.</p>
<p>이것은 자바스크립트에 포함되는 것이 아니다. 즉, 우리는 Web API의 내부는 조작할 수 없으며 호출만 가능하다. 또한 자바스크립트 언어를 사용하는데 있어 강력한 성능을 제공한다.</p>
<p>Web API의 종류는 <a href="https://developer.mozilla.org/en-US/docs/Web/API">다음</a>을 참조하면 알 수 있다.</p>
<a class="header" href="#콜백함수" id="콜백함수"><h3>콜백함수</h3></a>
<p>자바스크립트의 싱글 쓰레드 구조에서 비동기성의 이벤트 기반 실행(대표적으로 <code>setTimeout</code>)이나 <code>ajax</code>요청이 필요하다면, 콜백 함수를 큐로 보내고 큐에서는 호출 스택으로 보내 해결하게 된다.</p>
<p>자바스크립트에서는 쓰레드를 통해 병렬처리가 안되기 때문에 콜백 함수의 사용은 필수불가결하게 되는 것이다.</p>
<a class="header" href="#event-queue이벤트-큐" id="event-queue이벤트-큐"><h3>Event Queue(이벤트 큐)</h3></a>
<p>이벤트 큐는 말 그대로 콜백 함수들이 대기하는 <code>Queue</code>이며 <code>FIFO(First-In-First-Out)</code>의 구조를 갖는다. 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 호출 스택에 넣어주는 역할을 해준다.</p>
<a class="header" href="#이벤트-루프를-통한-비동기적-처리" id="이벤트-루프를-통한-비동기적-처리"><h3>이벤트 루프를 통한 비동기적 처리</h3></a>
<p>이벤트 루프의 역할은 생각보다 단순한다. 호출 스택에 실행 중인 작업이 있는지, 이벤트 큐에 대기 중인 작업이 있는지 반복해서 확인한다. 만약 호출 스택이 비어있다면 이벤트 큐에 있는 작업을 호출 스택으로 옮긴다. 그리고 이 작업을 수행하는 것은 결국 호출 스택이다.</p>
<pre><code class="language-js">function func1() {
  console.log(&quot;func1&quot;);
  func2();
}

function func2() {
  setTimeout(function() {
    console.log(&quot;func2&quot;);
  }, 0);

  func3();
}

function func3() {
  console.log(&quot;func3&quot;);
}

func1();
</code></pre>
<p>위 예제는 이벤트 루프를 설명할 때 가장 많이 사용되는 예제다. 만약, 이벤트 루프가 수행하는 과정이 없고 순차적으로 호출 스택에만 쌓이게 된다면 <code>func1</code>, <code>func2</code>, <code>func3</code>의 순서로 출력될 것이다. 하지만 실제로 위 코드를 실행해보면 <code>func1</code>, <code>func3</code>, <code>func2</code>의 순서로 출력되는 것을 볼 수 있을 것이다. 이런 결과가 나오는 이유는 위에서 설명한 것 처럼 이벤트 큐와 이벤트 루프를 통해 비동기 처리를 수행하는 <code>setTimeout</code>함수가 다른 함수들과 다르게 동작하기 때문이다.</p>
<p>아래 이미지는 위 코드가 실행되는 과정을 보여준다.</p>
<p><img src="https://github.com/Im-D/Dev-Docs/raw/master/assets/images/event_loop_gif.gif" alt="event_loop_gif" /></p>
<blockquote>
<p>이미지 출처: https://poiemaweb.com/js-event</p>
</blockquote>
<p><br/></p>
<p>위 과정을 순차적으로 정리하면 다음과 같다.</p>
<blockquote>
<ol>
<li><code>func1</code>함수가 호출되고 이는 호출 스택에 올라가고 <code>console.log('func1')</code>이 실행된다.</li>
<li><code>func2</code>함수가 호출 스택에 올라가고 <code>setTimout</code>함수를 호출한다.</li>
<li>호출된 <code>setTimeout</code>함수의 수행은 비동기적 처리를 수행하는 Web API에 넘어간다.</li>
<li><code>func3</code>함수가 호출 스택에 올라가고 <code>console.log('func3')</code>이 실행된다.</li>
<li>Web API에서 <code>setTimout</code>함수에서 지정한 시간이 지나면 <code>callback</code>함수를 이벤트 큐로 넘긴다.</li>
<li>작업이 끝난 <code>func3</code>, <code>func2</code>, <code>func1</code>은 순차적으로 호출 스택에서 제거된다.</li>
<li>이벤트 루프는 호출 스택에 작업 중인 태스크가 없는 것을 확인하고 이벤트 큐에 있는 <code>callback</code>함수를 호출 스택으로 올린다.</li>
<li>호출 스택에 올라간 <code>callback</code>함수가 실행되면서 <code>console.log('func3')</code>가 실행된다.</li>
</ol>
</blockquote>
<p>위 설명에서 주의 깊게 볼 것은 비동기 함수인 <code>setTimeout</code>함수에 세팅된 시간이 3초라면 <code>3초 후에 콜백 함수를 실행시켜라</code>가 아닌 <code>3초 후에 콜백 함수를 이벤트 큐에 넣어라</code>가 된다는 것이다.</p>
<p>즉, <code>setTimeout</code> 함수는 n초 뒤에 콜백을 단순히 큐에 집어넣는게 끝이다. 코드를 간단히 보자면 아래와 같다.</p>
<pre><code class="language-js">var eventLoop = [];
var event;

while (true) {
  // 틱!
  if (eventLoop.length &gt; 0) {
    event = eventLoop.shift();
  }

  try {
    event(); // 호출스택으로 밀어넣는다
  } catch (err) {
    //...
  }
}
</code></pre>
<p>이 큐에 이미 대기번호가 100개가 있다면 <code>func3</code>는 101번째 대기표를 받게 될 것이다. 따라서 <code>setTimeout</code>은 지정한 시간동안은 실행되지 않는 것은 보장할 수 있지만 지정한 시간에 실행되는것은 보장할 수 없다.</p>
<pre><code class="language-js">while (await messageQueue.nextMessage()) {
  let message = messageQueue.shift();
  message.run();
}
</code></pre>
<p>결론적으로, 이벤트 루프는 메시지 큐에 메시지가 더 있는지 확인하는 루프이다.</p>
<p>메시지 큐에 메시지가 있으면 메시지 큐에서 다음 메시지를 제거하고 그 메시지와 연관된 기능을 호출 스택으로 보낸다. 그렇지 않으면 새 메시지가 메시지 대기열에 추가될 때까지 대기를 한다. 이벤트 루프가 자바스크립트에게 비동기를 허용하는 기본 모델이다.</p>
<a class="header" href="#es6이후의-변화된-비동기-처리와-이벤트-루프" id="es6이후의-변화된-비동기-처리와-이벤트-루프"><h3>ES6이후의 변화된 비동기 처리와 이벤트 루프</h3></a>
<p>기본적으로 이벤트 루프는 위에서 설명한 내용이 큰 틀이다. 큐와 스택을 감시하며 스택의 작업이 없으면 큐의 작업을 스택에 올린다. 다만, <code>ES6</code>이후에는 몇 가지 비동기적 작업을 수행하는 API들이 추가되었고 이에 따라 약간의 추가된 내용이 있다. 하지만, 전체적인 실행 방식은 동일하며 각각의 비동기 처리에 수행 순서에 초점을 두고 살펴보자.</p>
<p>기존에 살펴보았던 이벤트 큐(Event Queue)를 좀 더 자세히 나눠보면 다음과 같다.</p>
<ol>
<li><code>Task Queue</code> : 가장 사람들이 잘 알고 있는 비동기 작업인 <code>setTimeout</code>이 들어가는 큐</li>
<li><code>Micro Task Queue</code> : ES6에서 추가된 <code>Promise</code>와 ES8의 <code>Async Await</code>(Async Await도 결국 Promise)</li>
<li><code>AnimationFrame</code>: <code>requestAnimationFrame(rAF)</code>의 콜백 함수가 들어간다.</li>
</ol>
<pre><code class="language-js">console.log(&quot;script start&quot;);

setTimeout(function() {
  console.log(&quot;setTimeout&quot;);
}, 0);

Promise.resolve().then(function() {
  console.log(&quot;promise1&quot;);
}).then(function() {
  console.log(&quot;promise2&quot;);
});

requestAnimationFrame(function {
    console.log(&quot;requestAnimationFrame&quot;);
})
console.log(&quot;script end&quot;);
</code></pre>
<p>위의 코드를 실행하면 다음과 같은 결과가 출력된다.</p>
<pre><code class="language-js">script start
script end
promise1
promise2
requestAnimationFrame
setTimeout
</code></pre>
<p>즉, 이벤트 큐에서 나눠지는 3가지 영역의 우선 순위는 다음과 같다.</p>
<blockquote>
<p>Micro Task Queue =&gt; AnimationFrame =&gt; Task Queue</p>
</blockquote>
<p>기존에 이벤트 루프에 대해서 이해가 된 상태라면 이 내용은 크게 어렵지 않다. 쉽게 보면 비동기 작업을 처리하는 방법이 추가되었고 이에 따라 이벤트 큐에서 내부적으로 처리하는 로직에 약간의 변화가 생겼을 뿐이다. 결국, 정리하면 다음과 같다.</p>
<ol>
<li>
<p>비동기 작업으로 등록되는 작업은 <code>Task</code>와 <code>Micro Task</code>, 그리고 <code>AnimationFrame</code>으로 구분된다.</p>
</li>
<li>
<p><code>Micro Task</code>는 <code>Task</code>보다 먼저 처리된다.</p>
</li>
<li>
<p><code>Micro Task</code>가 처리된 이후 <code>requestAnimationFrame</code>이 호출되고 이후 브라우저 랜더링이 발생한다.</p>
</li>
</ol>
<ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Task Queue와 Micro Task Queue의 처리 과정</a></li>
</ul>
<hr />
<a class="header" href="#-reference-13" id="-reference-13"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EB%A3%A8%ED%94%84(Event%20Loop).md">Im-D/Dev-Docs</a></li>
<li><a href="https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4">JavaScript Event Loop Explained</a></li>
<li><a href="https://www.wptutor.io/web/js/javascript-event-loop">What is the Event Loop in Javascript</a></li>
<li><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40">Understanding JS: The Event Loop</a></li>
<li><a href="https://code.likeagirl.io/what-the-heck-is-event-loop-1e414fccef49">Event loop in javascript</a></li>
<li><a href="https://flaviocopes.com/javascript-event-loop/">The JavaScript Event Loop</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://poiemaweb.com/js-event">Poiemaweb - 자바스크립트/이벤트</a></li>
</ul>
<a class="header" href="#이벤트-루프event-loop-1" id="이벤트-루프event-loop-1"><h2>이벤트 루프(Event Loop)</h2></a>
<a class="header" href="#자바스크립트는-싱글쓰레드-기반이다-1" id="자바스크립트는-싱글쓰레드-기반이다-1"><h3>자바스크립트는 싱글쓰레드 기반이다.</h3></a>
<p>자바스크립트를 공부해본 개발자라면 한 번쯤은 <code>자바스크립트는 싱글 쓰레드 기반의 언어다.</code>라는 말을 들어봤을 것이다. 하지만 우리는 실제 웹 애플리케이션에서 여러 개의 작업이 동시에 처리되는 것처럼(비동기적) 느끼는 일이 더 많다. 싱글 쓰레드 기반의 언어에서 즉, 한 번에 하나의 작업만 처리가능한 환경에서 어떻게 많은 작업이 동시에 처리되는 것처럼 느낄 수 있을까? 그 답은 <strong>이벤트 루프</strong>에 있다.</p>
<p>브라우저 환경을 간단히 표현하면 다음 이미지와 같다.</p>
<p><img src="https://github.com/Im-D/Dev-Docs/raw/master/assets/images/event_loop.jpeg" alt="eventLoop" /></p>
<p>우선, 위의 그림에서 보여지는 각각에 대해서 살펴본 후, 전체적으로 이벤트 루프가 동작하는 방식을 살펴보도록 하자.</p>
<a class="header" href="#자바스크립트-엔진-1" id="자바스크립트-엔진-1"><h3>자바스크립트 엔진</h3></a>
<a class="header" href="#heap-1" id="heap-1"><h4>Heap</h4></a>
<p>동적으로 생성된 객체 인스턴스는 Heap에 할당이 된다. Heap은 메모리에서 대부분 구조화되지 않은 영역을 나타낸다.</p>
<a class="header" href="#call-stack호출-스택-1" id="call-stack호출-스택-1"><h4>Call Stack(호출 스택)</h4></a>
<p>호출 스택은 이름 그대로 <code>Stack</code>이며 LIFO(Last-In-First-Out)구조를 갖는다. 함수를 호출하면(작업을 요청하면) 작업은 순차적으로 호출 스택에 쌓이고 실행된다. 자바스크립트 엔진은 하나의 스택만 가지고 있기 때문에 하나의 작업이 끝나기 전까지 다른 작업을 수행할 수 없다.</p>
<a class="header" href="#web-apis-1" id="web-apis-1"><h3>Web APIs</h3></a>
<p>흔히 WebAPI라 불리는 API들은 실행환경에 내장되어 있다.</p>
<p>이것은 자바스크립트에 포함되는 것이 아니다. 즉, 우리는 Web API의 내부는 조작할 수 없으며 호출만 가능하다. 또한 자바스크립트 언어를 사용하는데 있어 강력한 성능을 제공한다.</p>
<p>Web API의 종류는 <a href="https://developer.mozilla.org/en-US/docs/Web/API">다음</a>을 참조하면 알 수 있다.</p>
<a class="header" href="#콜백함수-1" id="콜백함수-1"><h3>콜백함수</h3></a>
<p>자바스크립트의 싱글 쓰레드 구조에서 비동기성의 이벤트 기반 실행(대표적으로 <code>setTimeout</code>)이나 <code>ajax</code>요청이 필요하다면, 콜백 함수를 큐로 보내고 큐에서는 호출 스택으로 보내 해결하게 된다.</p>
<p>자바스크립트에서는 쓰레드를 통해 병렬처리가 안되기 때문에 콜백 함수의 사용은 필수불가결하게 되는 것이다.</p>
<a class="header" href="#event-queue이벤트-큐-1" id="event-queue이벤트-큐-1"><h3>Event Queue(이벤트 큐)</h3></a>
<p>이벤트 큐는 말 그대로 콜백 함수들이 대기하는 <code>Queue</code>이며 <code>FIFO(First-In-First-Out)</code>의 구조를 갖는다. 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 호출 스택에 넣어주는 역할을 해준다.</p>
<a class="header" href="#이벤트-루프를-통한-비동기적-처리-1" id="이벤트-루프를-통한-비동기적-처리-1"><h3>이벤트 루프를 통한 비동기적 처리</h3></a>
<p>이벤트 루프의 역할은 생각보다 단순한다. 호출 스택에 실행 중인 작업이 있는지, 이벤트 큐에 대기 중인 작업이 있는지 반복해서 확인한다. 만약 호출 스택이 비어있다면 이벤트 큐에 있는 작업을 호출 스택으로 옮긴다. 그리고 이 작업을 수행하는 것은 결국 호출 스택이다.</p>
<pre><code class="language-js">function func1() {
  console.log(&quot;func1&quot;);
  func2();
}

function func2() {
  setTimeout(function() {
    console.log(&quot;func2&quot;);
  }, 0);

  func3();
}

function func3() {
  console.log(&quot;func3&quot;);
}

func1();
</code></pre>
<p>위 예제는 이벤트 루프를 설명할 때 가장 많이 사용되는 예제다. 만약, 이벤트 루프가 수행하는 과정이 없고 순차적으로 호출 스택에만 쌓이게 된다면 <code>func1</code>, <code>func2</code>, <code>func3</code>의 순서로 출력될 것이다. 하지만 실제로 위 코드를 실행해보면 <code>func1</code>, <code>func3</code>, <code>func2</code>의 순서로 출력되는 것을 볼 수 있을 것이다. 이런 결과가 나오는 이유는 위에서 설명한 것 처럼 이벤트 큐와 이벤트 루프를 통해 비동기 처리를 수행하는 <code>setTimeout</code>함수가 다른 함수들과 다르게 동작하기 때문이다.</p>
<p>아래 이미지는 위 코드가 실행되는 과정을 보여준다.</p>
<p><img src="https://github.com/Im-D/Dev-Docs/raw/master/assets/images/event_loop_gif.gif" alt="event_loop_gif" /></p>
<blockquote>
<p>이미지 출처: https://poiemaweb.com/js-event</p>
</blockquote>
<p><br/></p>
<p>위 과정을 순차적으로 정리하면 다음과 같다.</p>
<blockquote>
<ol>
<li><code>func1</code>함수가 호출되고 이는 호출 스택에 올라가고 <code>console.log('func1')</code>이 실행된다.</li>
<li><code>func2</code>함수가 호출 스택에 올라가고 <code>setTimout</code>함수를 호출한다.</li>
<li>호출된 <code>setTimeout</code>함수의 수행은 비동기적 처리를 수행하는 Web API에 넘어간다.</li>
<li><code>func3</code>함수가 호출 스택에 올라가고 <code>console.log('func3')</code>이 실행된다.</li>
<li>Web API에서 <code>setTimout</code>함수에서 지정한 시간이 지나면 <code>callback</code>함수를 이벤트 큐로 넘긴다.</li>
<li>작업이 끝난 <code>func3</code>, <code>func2</code>, <code>func1</code>은 순차적으로 호출 스택에서 제거된다.</li>
<li>이벤트 루프는 호출 스택에 작업 중인 태스크가 없는 것을 확인하고 이벤트 큐에 있는 <code>callback</code>함수를 호출 스택으로 올린다.</li>
<li>호출 스택에 올라간 <code>callback</code>함수가 실행되면서 <code>console.log('func3')</code>가 실행된다.</li>
</ol>
</blockquote>
<p>위 설명에서 주의 깊게 볼 것은 비동기 함수인 <code>setTimeout</code>함수에 세팅된 시간이 3초라면 <code>3초 후에 콜백 함수를 실행시켜라</code>가 아닌 <code>3초 후에 콜백 함수를 이벤트 큐에 넣어라</code>가 된다는 것이다.</p>
<p>즉, <code>setTimeout</code> 함수는 n초 뒤에 콜백을 단순히 큐에 집어넣는게 끝이다. 코드를 간단히 보자면 아래와 같다.</p>
<pre><code class="language-js">var eventLoop = [];
var event;

while (true) {
  // 틱!
  if (eventLoop.length &gt; 0) {
    event = eventLoop.shift();
  }

  try {
    event(); // 호출스택으로 밀어넣는다
  } catch (err) {
    //...
  }
}
</code></pre>
<p>이 큐에 이미 대기번호가 100개가 있다면 <code>func3</code>는 101번째 대기표를 받게 될 것이다. 따라서 <code>setTimeout</code>은 지정한 시간동안은 실행되지 않는 것은 보장할 수 있지만 지정한 시간에 실행되는것은 보장할 수 없다.</p>
<pre><code class="language-js">while (await messageQueue.nextMessage()) {
  let message = messageQueue.shift();
  message.run();
}
</code></pre>
<p>결론적으로, 이벤트 루프는 메시지 큐에 메시지가 더 있는지 확인하는 루프이다.</p>
<p>메시지 큐에 메시지가 있으면 메시지 큐에서 다음 메시지를 제거하고 그 메시지와 연관된 기능을 호출 스택으로 보낸다. 그렇지 않으면 새 메시지가 메시지 대기열에 추가될 때까지 대기를 한다. 이벤트 루프가 자바스크립트에게 비동기를 허용하는 기본 모델이다.</p>
<a class="header" href="#es6이후의-변화된-비동기-처리와-이벤트-루프-1" id="es6이후의-변화된-비동기-처리와-이벤트-루프-1"><h3>ES6이후의 변화된 비동기 처리와 이벤트 루프</h3></a>
<p>기본적으로 이벤트 루프는 위에서 설명한 내용이 큰 틀이다. 큐와 스택을 감시하며 스택의 작업이 없으면 큐의 작업을 스택에 올린다. 다만, <code>ES6</code>이후에는 몇 가지 비동기적 작업을 수행하는 API들이 추가되었고 이에 따라 약간의 추가된 내용이 있다. 하지만, 전체적인 실행 방식은 동일하며 각각의 비동기 처리에 수행 순서에 초점을 두고 살펴보자.</p>
<p>기존에 살펴보았던 이벤트 큐(Event Queue)를 좀 더 자세히 나눠보면 다음과 같다.</p>
<ol>
<li><code>Task Queue</code> : 가장 사람들이 잘 알고 있는 비동기 작업인 <code>setTimeout</code>이 들어가는 큐</li>
<li><code>Micro Task Queue</code> : ES6에서 추가된 <code>Promise</code>와 ES8의 <code>Async Await</code>(Async Await도 결국 Promise)</li>
<li><code>AnimationFrame</code>: <code>requestAnimationFrame(rAF)</code>의 콜백 함수가 들어간다.</li>
</ol>
<pre><code class="language-js">console.log(&quot;script start&quot;);

setTimeout(function() {
  console.log(&quot;setTimeout&quot;);
}, 0);

Promise.resolve().then(function() {
  console.log(&quot;promise1&quot;);
}).then(function() {
  console.log(&quot;promise2&quot;);
});

requestAnimationFrame(function {
    console.log(&quot;requestAnimationFrame&quot;);
})
console.log(&quot;script end&quot;);
</code></pre>
<p>위의 코드를 실행하면 다음과 같은 결과가 출력된다.</p>
<pre><code class="language-js">script start
script end
promise1
promise2
requestAnimationFrame
setTimeout
</code></pre>
<p>즉, 이벤트 큐에서 나눠지는 3가지 영역의 우선 순위는 다음과 같다.</p>
<blockquote>
<p>Micro Task Queue =&gt; AnimationFrame =&gt; Task Queue</p>
</blockquote>
<p>기존에 이벤트 루프에 대해서 이해가 된 상태라면 이 내용은 크게 어렵지 않다. 쉽게 보면 비동기 작업을 처리하는 방법이 추가되었고 이에 따라 이벤트 큐에서 내부적으로 처리하는 로직에 약간의 변화가 생겼을 뿐이다. 결국, 정리하면 다음과 같다.</p>
<ol>
<li>
<p>비동기 작업으로 등록되는 작업은 <code>Task</code>와 <code>Micro Task</code>, 그리고 <code>AnimationFrame</code>으로 구분된다.</p>
</li>
<li>
<p><code>Micro Task</code>는 <code>Task</code>보다 먼저 처리된다.</p>
</li>
<li>
<p><code>Micro Task</code>가 처리된 이후 <code>requestAnimationFrame</code>이 호출되고 이후 브라우저 랜더링이 발생한다.</p>
</li>
</ol>
<ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Task Queue와 Micro Task Queue의 처리 과정</a></li>
</ul>
<hr />
<a class="header" href="#-reference-14" id="-reference-14"><h4>🙏 Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Javascript/%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EB%A3%A8%ED%94%84(Event%20Loop).md">Im-D/Dev-Docs</a></li>
<li><a href="https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4">JavaScript Event Loop Explained</a></li>
<li><a href="https://www.wptutor.io/web/js/javascript-event-loop">What is the Event Loop in Javascript</a></li>
<li><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40">Understanding JS: The Event Loop</a></li>
<li><a href="https://code.likeagirl.io/what-the-heck-is-event-loop-1e414fccef49">Event loop in javascript</a></li>
<li><a href="https://flaviocopes.com/javascript-event-loop/">The JavaScript Event Loop</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://poiemaweb.com/js-event">Poiemaweb - 자바스크립트/이벤트</a></li>
</ul>
<a class="header" href="#repaint와-reflow" id="repaint와-reflow"><h2>repaint와 reflow</h2></a>
<p><img src="https://github.com/Im-D/Dev-Docs/raw/master/assets/images/rendering.png" alt="rendering" /></p>
<p>위의 그림과 같이 브라우저는 화면을 rendering하는 과정에서 <strong>배치(flow)</strong> 와 <strong>그리기(paint)</strong> 의 과정을 거친다.</p>
<p>생성된 DOM 노드의 레이아웃이 변경될 떄, 변경 후 영향을 받는 모든 노드를 다시 계산하고 렌더 트리를 재생성 한다.
이러한 과정을 <code>reflow</code>라 하고 <code>reflow</code>가 일어난 후, <code>repaint</code>가 일어난다.</p>
<p>즉, <strong>DOM의 노드가 변경될 때 마다 DOM tree라는 자료구조에 접근</strong>해야 하기 때문에 DOM의 레이아웃을 변경하는 코드를 작성할 때는 이를 최적화하기 위한 고민이 필요하다.</p>
<a class="header" href="#reflow" id="reflow"><h3>reflow</h3></a>
<pre><code class="language-js">function reFlow() {
    var container = document.getElementById('container');

    container.appendChild(document.createTextNode('hello'));
}
</code></pre>
<p>위의 코드를 보면 <code>conatiner</code>라는 엘리먼트에 <code>hello</code>라는 <code>TextNode</code>를 추가했다. 이로 인해 DOM 노드의 레이아웃이 바뀌며 <code>reflow</code>와 <code>repaint</code>가 일어날 것이다.</p>
<a class="header" href="#repaint" id="repaint"><h3>repaint</h3></a>
<pre><code class="language-js">function repaint() {
    var container = document.getElementById('container');

    container.style.backgroundColor = 'black';
    container.style.color = 'white';
}
</code></pre>
<p>위의 코드에서는 이전의 코드와 다르게 엘리먼트의 <code>style</code>만 변경했다. 이러한 경우 DOM 노드의 레이아웃은 변경되지 않았고 <code>style</code>속성만 변경되었기 때문에 <code>reflow</code>는 일어나지 않고 <code>repaint</code>만 일어나게 된다.</p>
<p><code>reflow</code>와 <code>repaint</code>가 많아질수록 애플리케이션의 렌더링 성능은 느려지게 되기 때문에 이를 줄일 수록 성능을 높일 수 있다.</p>
<hr />
<a class="header" href="#--reference" id="--reference"><h4>🙏  Reference</h4></a>
<ul>
<li><a href="https://github.com/Im-D/Dev-Docs/blob/master/Performance/Repaint%EC%99%80%20Reflow.md">Im-D/Dev-Docs - Refaint와 Reflow</a></li>
<li><a href="http://webclub.tistory.com/346">Reflow or Repaint(or ReDraw)과정 설명 및 최적화 방법</a></li>
<li><a href="https://velopert.com/775">DOM의 문제점과 Virtual DOM</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
